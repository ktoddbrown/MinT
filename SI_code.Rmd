---
title: The effect of restricted substrate diffusion on microbial community function and structure
author: "Petr Capek, Katherine Todd-Brown, Natalie Sadler, Jianqiu Zheng, Nancy Hess, Kirsten Hofmockel"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Supplementary Information
## Step-by-step analysis and code

The analysis requires several libraries

```{r libraries loading, message=FALSE, warning=FALSE}

##libraries
library(deSolve)
library(dplyr)
library(FME)
library(reshape)
library(ggplot2)
library(foreach)
library(doParallel)
library(openxlsx)
library(DEoptim)
library(gridExtra)
library(kableExtra)
library(lmerTest)
library(psycho)
library(ggeffects)
library(rcompanion)
library(vegan)

##ggplot theme
theme_min<-theme(axis.text.x=element_text(vjust=0.2, size=18, colour="black"),
                 axis.text.y=element_text(hjust=0.2, size=18, colour="black"),
                 axis.title=element_text(size=18, colour="black"),
                 axis.line=element_line(size=0.5, colour="black"),
                 strip.text=element_text(size=18, face="bold"),
                 axis.ticks=element_line(size=1, colour="black"),
                 axis.ticks.length=unit(-0.05, "cm"),
                 panel.background=element_rect(colour="black", fill="white"),
                 panel.grid=element_line(linetype=0),
                 legend.text=element_text(size=14, colour="black"),
                 legend.title=element_text(size=14, colour="black"),
                 legend.position=c("right"),
                 legend.key.size=unit(1, "cm"),
                 strip.background=element_rect(fill="grey98", colour="black"),
                 legend.key=element_rect(fill="white", size=1.2),
                 legend.spacing=unit(0.5, "cm"),
                 plot.title=element_text(size=18, face="bold", hjust=-0.05))
```

Data are available at https://github.com/petacapek/MinT.

```{r data loading, echo=FALSE}

#respiration rates in umol/ml/h
resp<-read.csv(file=c("data_checked_respiration_raw.csv"))

#arrange the data
resp.ordered<-resp[order(resp$Sample, resp$Day), ]

#biological data
biology<-read.csv(file=c("data_checked_biology_raw.csv"))

#arrange the data in the same way
biology.ordered<-biology[order(biology$Sample, biology$Day), -c(2,3)]
biology.ordered$Sample<-paste0("CSub3_", biology.ordered$Sample)

#merging both data sets
m0<-merge(resp.ordered, biology.ordered, by.x=c("Sample", "Day"), by.y = c("Sample", "Day"), all=T)

#Bacteria
bac<-as.data.frame(t(read.csv(file=c("bacteria.csv"), skip = 4)[,-1]))
colnames(bac)<-t(read.csv(file=c("bacteria.csv"), skip = 4)[,1])

bac_env<-as.data.frame(t(read.csv(file=c("bacteria.csv"), nrows = 4, header = F)[,-1]))
colnames(bac_env)<-t(read.csv(file=c("bacteria.csv"), nrows = 4, header = F)[,1])

bac_env$Structure<-recode(bac_env$Structure, 'Broth'="BROTH", 'Glass wool'="WOOL",
                          'Mixed glass'="GLASS")

#Fungi
fungi<-as.data.frame(t(read.csv(file=c("fungi.csv"), skip = 4)[,-1]))
colnames(fungi)<-t(read.csv(file=c("fungi.csv"), skip = 4)[,1])

fungi_env<-as.data.frame(t(read.csv(file=c("fungi.csv"), nrows = 4, header = F)[,-1]))
colnames(fungi_env)<-t(read.csv(file=c("fungi.csv"), nrows = 4, header = F)[,1])

fungi_env$Structure<-recode(fungi_env$Structure, 'Broth'="BROTH", 'Glass wool'="WOOL",
                          'Mixed glass'="GLASS")

```

The conducted experiment is large. For this analysis, only subset of data is used. We use treatments with Glucose or Celluloze as a single source of organic carbon and all three levels of incubation system complexity (i.e. broth, glass wool and mix of glass beads).

```{r data filtering}

d<-subset(m0, Substrate=="Glucose" | Substrate=="Cellobiose")
summary(d)

#removing outliers
#respiration rate
ggplot(d, aes(Time, r))+geom_point(cex=6)+facet_wrap(Structure~Substrate, scales="free")

d[(d$Substrate=="Glucose" & d$Structure=="Glass wool" & d$Time>20 & d$Time<30 & d$r<0.4 & !is.na(d$r)), "r"]<-NA

#Proteins
ggplot(d, aes(Time, Prot.in))+geom_point(cex=6)+facet_wrap(Structure~Substrate, scales="free")

d[(d$Substrate=="Cellobiose" & d$Structure=="Broth" &  d$Time>75), "Prot.in"]<-NA
d[(d$Substrate=="Glucose" & d$Structure=="Broth" & d$Time>75), "Prot.in"]<-NA
d[(d$Substrate=="Cellobiose" & d$Structure=="Mixed glass" & d$Time>75), "Prot.in"]<-NA
d[(d$Substrate=="Cellobiose" & d$Structure=="Glass wool" & d$Time>75 & d$Prot.in>110 & !is.na(d$Prot.in)), "Prot.in"]<-NA


```

DNA and protein concentrations are in $\mu$grams per incubation vial. Both values are recalculated to unit of carbon per one ml of media in the vial (4 ml) using the conversion factors reported in Vrede et al. (2004).

```{r conversions}

d$Protc<-d$Prot.in*0.46/12.01/4
d$DNAc<-d$DNA*0.51/12.01/4

```
##Statistical analysis
Linear Mixed-Effect models are used to evaluate the effect of substrate and the type of physical barrier on measured respiration rate, DNA and protein concentration. Becuase all three variables display significant variability over time, the time of measurement is treated as a random effect. Type of the barrier is nested within the substrate. 

```{r lme analysis, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
#respiration rate
lme1<-lmer(r~Substrate+Structure/Substrate + (1|Day), d)
#Proteins
lme2<-lmer(Protc~Substrate+Structure/Substrate + (1|Day), d)
#DNA
lme3<-lmer(DNAc~Substrate+Structure/Substrate + (1|Day), d)

t.s0<-as.data.frame(cbind(anova(lme1)[c(5,3,6)], anova(lme2)[c(5,3,6)], anova(lme3)[c(5,3,6)]))

row.names(t.s0)<-c("Substrate", "Structure", "Substrate*Structure")

kable(t.s0, digits = c(2, 1, 3, 2, 1, 3, 2, 1, 3), align = 'c', "html", booktabs=T, col.names = c("F", "df", "p", "F", "df", "p", "F", "df", "p"), row.names=T, caption = "_**Table S1:** Results of linear mixed-effects model analysis. Effect of substrate, the type of physical barrier (Structure) and their interaction was evaluated. Statistical analysis was conducted for measured respiration rate, cellular protein concentration and DNA. F values, degrees of freedom (df) and the probability (p) are reported._") %>% 
  kable_styling() %>% 
  add_header_above(c(" " = 1, "Respiration rate" = 3, "Cellular Proteins" = 3, "DNA" = 3),
                   italic=T)


```
$~$
$~$
$~$
$~$
$~$
$~$

```{r lme effects, echo=FALSE, fig.height=5, fig.width=15, message=FALSE, paged.print=FALSE, fig.cap="Fig. S1: Marginal effects of the substrate (Glucose or Cellobiose) and the type of physical barrier (BROTH, GLASS, WOOL) on the respiration rate (a), cellular proteins (b) and DNA concentration (c) estimated by the linear mixed-effect model."}
#respiration
lme1_contr<-get_contrasts(lme1)
lme1_effects<-ggpredict(lme1, c("Substrate", "Structure"), type="fe")
lme1_effects$x<-c(rep("Cellobiose", 3), rep("Glucose", 3))
lme1_effects$group<-c(rep(c("BROTH", "WOOL", "GLASS"), 2))
lme1_effects<-lme1_effects[order(lme1_effects$group), ]
lme1_effects$letters<-c(as.character(cldList(p ~ Contrast, data      = lme1_contr, threshold = 0.05)[[2]])[c(1:2, 5:6)], as.character(cldList(p ~ Contrast, data      = lme1_contr, threshold = 0.05)[[2]])[c(3:4)])
#Proteins
lme2_contr<-get_contrasts(lme2)
lme2_effects<-ggpredict(lme2, c("Substrate", "Structure"), type="fe")
lme2_effects$x<-c(rep("Cellobiose", 3), rep("Glucose", 3))
lme2_effects$group<-c(rep(c("BROTH", "WOOL", "GLASS"), 2))
lme2_effects<-lme2_effects[order(lme2_effects$group), ]
lme2_effects$letters<-c(as.character(cldList(p ~ Contrast, data      = lme2_contr, threshold = 0.05)[[2]])[c(1:2, 5:6)], as.character(cldList(p ~ Contrast, data      = lme2_contr, threshold = 0.05)[[2]])[c(3:4)])
#DNA
lme3_contr<-get_contrasts(lme3)
lme3_effects<-ggpredict(lme3, c("Substrate", "Structure"), type="fe")
lme3_effects$x<-c(rep("Cellobiose", 3), rep("Glucose", 3))
lme3_effects$group<-c(rep(c("BROTH", "WOOL", "GLASS"), 2))
lme3_effects<-lme3_effects[order(lme3_effects$group), ]
lme3_effects$letters<-c(as.character(cldList(p ~ Contrast, data      = lme3_contr, threshold = 0.05)[[2]])[c(1:2, 5:6)], as.character(cldList(p ~ Contrast, data      = lme3_contr, threshold = 0.05)[[2]])[c(3:4)])

p1<-ggplot(lme1_effects, aes(x, predicted))+
    geom_point(position = position_dodge(width = 0.5), aes(fill=group), shape=21, cex=6, show.legend = F)+
    scale_fill_manual(values = c("black", "grey", "white"))+
    scale_colour_manual(values = c("black", "black", "black"))+
    geom_errorbar(aes(ymin=predicted-std.error, ymax=predicted+std.error, colour=group),
                  position=position_dodge(width = 0.5), width=0.1, show.legend = F)+
    ylab(expression(paste("Respiration rate (", mu, "mol",(C-CO[2])~ml^{-1}~h^{-1}, ")")))+
    ggtitle("a)")+
    geom_text(aes(label=letters, colour=group, vjust=-10, fontface="bold.italic"),
              cex=5, position=position_dodge(width = 0.5), show.legend = F)+
    ylim(-0.01,0.3)+
    theme_min+theme(axis.title.x = element_blank(),
                    legend.title = element_blank())
p2<-ggplot(lme2_effects, aes(x, predicted))+
    geom_point(position = position_dodge(width = 0.5), aes(fill=group), shape=21, cex=6, show.legend = F)+
    scale_fill_manual(values = c("black", "grey", "white"))+
    scale_colour_manual(values = c("black", "black", "black"))+
    geom_errorbar(aes(ymin=predicted-std.error, ymax=predicted+std.error, colour=group),
                  position=position_dodge(width = 0.5), width=0.1, show.legend = F)+
    ylab(expression(paste("Cellular Proteins (", mu, "mol",(C[Proteins])~ml^{-1}, ")")))+
    ggtitle("b)")+
    geom_text(aes(label=letters, colour=group, vjust=-3, fontface="bold.italic"),
              cex=5, position=position_dodge(width = 0.5), show.legend = F)+
    ylim(0,1.2)+
    theme_min+theme(axis.title.x = element_blank(),
                    legend.title = element_blank())
p3<-ggplot(lme3_effects, aes(x, predicted))+
    geom_point(position = position_dodge(width = 0.5), aes(fill=group), shape=21, cex=6)+
    scale_fill_manual(values = c("black", "grey", "white"))+
    scale_colour_manual(values = c("black", "black", "black"))+
    geom_errorbar(aes(ymin=predicted-std.error, ymax=predicted+std.error, colour=group),
                  position=position_dodge(width = 0.5), width=0.1)+
    ylab(expression(paste("DNA (", mu, "mol",(C[DNA])~ml^{-1}, ")")))+
    ggtitle("c)")+
    geom_text(aes(label=letters, colour=group, vjust=-3, fontface="bold.italic"),
              cex=5, position=position_dodge(width = 0.5), show.legend = F)+
    ylim(0,0.08)+
    theme_min+theme(axis.title.x = element_blank(),
                    legend.title = element_blank(),
                    legend.position = c(0.25,0.2))


grid.arrange(p1, p2, p3, nrow=1)

```
$~$
$~$
$~$
Next, the effect of the substrate and the presence of a physical barrier on microbial community structure and diversity is evaluated. First, the jaccard distance indices are calculated on a normalized data. Then, Permutational Multivariate Analysis of Variance is used to estimate the treatment effects. Analysis permutations are constrained to an individual times of incubation to avoid the potential confounding effect of time.   

```{r vegan analysis, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
#Bacteria
bac.norm<-decostand(bac, method=c("normalize"))
bac.dist<-vegdist(bac.norm, method = "jaccard")
bac.ad<-adonis(bac.dist~Substrate+Structure/Substrate, bac_env, strata = bac_env$Day)


#Fungi
fungi.norm<-decostand(fungi, method=c("normalize"))
fungi.dist<-vegdist(fungi.norm, method = "jaccard")
fungi.ad<-adonis(fungi.dist~Substrate+Structure/Substrate, fungi_env, strata = fungi_env$Day)


t.s01<-cbind(as.data.frame(bac.ad$aov[c(4, 1, 6)])[c(1:3), ], as.data.frame(fungi.ad$aov[c(4, 1, 6)])[c(1:3), ])

row.names(t.s01)<-c("Substrate", "Structure", "Substrate*Structure")

kable(t.s01, digits = c(2, 1, 3, 2, 1, 3), align = 'c', "html", booktabs=T, col.names = c("F", "df", "p", "F", "df", "p"), row.names=T, caption = "_**Table S2:** Results of permutational multivariate analysis of variance. Effect of substrate, the type of physical barrier (Structure) and their interaction was evaluated. Statistical analysis was conducted for bacterial and fungal part of the microbial community separately. F values, degrees of freedom (df) and the probability (p) are reported._") %>% 
  kable_styling() %>% 
  add_header_above(c(" " = 1, "Bacteria" = 3, "Fungi" = 3),
                   italic=T)


```
$~$
$~$
$~$
$~$
$~$
$~$
```{r community figure, echo=FALSE, fig.height=5, fig.width=10, fig.cap="Fig. S2: Multivariate distances between six experimental groups that combine two different substrate treatments (Glucose or Cellobiose) and three different types of physical barrier (BROTH, WOOL, GLASS - black, grey and empty symbols respectively) in respect to structure of bacterial ((a); 16S) and fungal ((b); ITS) part of microbial community."}
#Bacteria
bacm<-as.matrix(bac.dist)
#Intercept - Glucose - BROTH
mGB<-bacm[intersect(which(bac_env$Structure=="BROTH"),which(bac_env$Substrate=="Cellobiose")), 
       intersect(which(bac_env$Structure=="BROTH"),which(bac_env$Substrate=="Glucose"))]
mGB[mGB==0]<-NA
#Glucose - GLASS
mGG<-bacm[intersect(which(bac_env$Structure=="BROTH"),which(bac_env$Substrate=="Cellobiose")), 
       intersect(which(bac_env$Structure=="GLASS"),which(bac_env$Substrate=="Glucose"))]
mGG[mGG==0]<-NA
#Glucose - WOOL
mGW<-bacm[intersect(which(bac_env$Structure=="BROTH"),which(bac_env$Substrate=="Cellobiose")), 
       intersect(which(bac_env$Structure=="WOOL"),which(bac_env$Substrate=="Glucose"))]
mGW[mGW==0]<-NA
#Cellobiose - BROTH
mCB<-bacm[intersect(which(bac_env$Structure=="BROTH"),which(bac_env$Substrate=="Cellobiose")), 
       intersect(which(bac_env$Structure=="BROTH"),which(bac_env$Substrate=="Cellobiose"))]
mCB[mCB==0]<-NA
#Cellobiose - GLASS
mCG<-bacm[intersect(which(bac_env$Structure=="BROTH"),which(bac_env$Substrate=="Cellobiose")), 
       intersect(which(bac_env$Structure=="GLASS"),which(bac_env$Substrate=="Cellobiose"))]
mCG[mCG==0]<-NA
#Cellobiose - WOOL
mCW<-bacm[intersect(which(bac_env$Structure=="BROTH"),which(bac_env$Substrate=="Cellobiose")), 
       intersect(which(bac_env$Structure=="WOOL"),which(bac_env$Substrate=="Cellobiose"))]
mCW[mCW==0]<-NA

bacdiff<-data.frame(Dist=c(mean(mGB, na.rm=T), mean(mGG, na.rm=T), mean(mGW, na.rm=T), 0, mean(mCG, na.rm=T), mean(mCW, na.rm=T)),
                    Dist.sd=c(sd(mGB, na.rm=T), sd(mGG, na.rm=T), sd(mGW, na.rm=T), sd(mCB, na.rm=T), sd(mCG, na.rm=T), sd(mCW, na.rm=T)),
                    Substrate=c(rep("Glucose", 3), rep("Cellobiose", 3)),
                    Structure=rep(c("BROTH", "GLASS", "WOOL"), 2))

#Fungi
fm<-as.matrix(fungi.dist)
#Intercept - Glucose - BROTH
fGB<-fm[intersect(which(fungi_env$Structure=="BROTH"),which(fungi_env$Substrate=="Cellobiose")), 
          intersect(which(fungi_env$Structure=="BROTH"),which(fungi_env$Substrate=="Glucose"))]
fGB[fGB==0]<-NA
#Glucose - GLASS
fGG<-fm[intersect(which(fungi_env$Structure=="BROTH"),which(fungi_env$Substrate=="Cellobiose")), 
          intersect(which(fungi_env$Structure=="GLASS"),which(fungi_env$Substrate=="Glucose"))]
fGG[fGG==0]<-NA
#Glucose - WOOL
fGW<-fm[intersect(which(fungi_env$Structure=="BROTH"),which(fungi_env$Substrate=="Cellobiose")), 
          intersect(which(fungi_env$Structure=="WOOL"),which(fungi_env$Substrate=="Glucose"))]
fGW[fGW==0]<-NA
#Cellobiose - BROTH
fCB<-fm[intersect(which(fungi_env$Structure=="BROTH"),which(fungi_env$Substrate=="Cellobiose")), 
          intersect(which(fungi_env$Structure=="BROTH"),which(fungi_env$Substrate=="Cellobiose"))]
fCB[fCB==0]<-NA
#Cellobiose - GLASS
fCG<-fm[intersect(which(fungi_env$Structure=="BROTH"),which(fungi_env$Substrate=="Cellobiose")), 
          intersect(which(fungi_env$Structure=="GLASS"),which(fungi_env$Substrate=="Cellobiose"))]
fCG[fCG==0]<-NA
#Cellobiose - WOOL
fCW<-fm[intersect(which(fungi_env$Structure=="BROTH"),which(fungi_env$Substrate=="Cellobiose")), 
          intersect(which(fungi_env$Structure=="WOOL"),which(fungi_env$Substrate=="Cellobiose"))]
fCW[fCW==0]<-NA

fdiff<-data.frame(Dist=c(mean(fGB, na.rm=T), mean(fGG, na.rm=T), mean(fGW, na.rm=T), 0, mean(fCG, na.rm=T), mean(fCW, na.rm=T)),
                    Dist.sd=c(sd(fGB, na.rm=T), sd(fGG, na.rm=T), sd(fGW, na.rm=T), sd(fCB, na.rm=T), sd(fCG, na.rm=T), sd(fCW, na.rm=T)),
                    Substrate=c(rep("Glucose", 3), rep("Cellobiose", 3)),
                    Structure=rep(c("BROTH", "GLASS", "WOOL"), 2))

bacplot<-ggplot(bacdiff, aes(Substrate, Dist))+
  geom_point(position = position_dodge(width = 0.5), aes(fill=Structure), shape=21, cex=6)+
  scale_fill_manual(values = c("black", "grey", "white"))+
  scale_colour_manual(values = c("black", "black", "black"))+
  geom_errorbar(aes(ymin=Dist-Dist.sd, ymax=Dist+Dist.sd, colour=Structure),
                position=position_dodge(width = 0.5), width=0.1)+
  ylab("16S Distance")+
  ggtitle("a)")+
  theme_min+theme(axis.title.x = element_blank(),
                  legend.title = element_blank(),
                  legend.position = c(0.8, 0.2))
fplot<-ggplot(fdiff, aes(Substrate, Dist))+
  geom_point(position = position_dodge(width = 0.5), aes(fill=Structure), shape=21, cex=6, show.legend = F)+
  scale_fill_manual(values = c("black", "grey", "white"))+
  scale_colour_manual(values = c("black", "black", "black"))+
  geom_errorbar(aes(ymin=Dist-Dist.sd, ymax=Dist+Dist.sd, colour=Structure),
                position=position_dodge(width = 0.5), width=0.1, show.legend = F)+
  ylab("ITS Distance")+
  ggtitle("b)")+
  theme_min+theme(axis.title.x = element_blank(),
                  legend.title = element_blank())

grid.arrange(bacplot, fplot, nrow=1)

```

$~$
$~$
$~$

##Microbial-explicit models analysis
###All models are first calibrated against respiration rate
Calibration of each model is done in four steps. First, the model is calibrated against data across all treatments. Second, the model is calibrated for each level of incubation system complexity separately. Third, the model is calibrated for Glucose and Cellobiose treatments separately. Fourth, the model is calibrated for each experimental treatment separately. 
Goodness of correspondence between measurements and model simulations are calculated across all treatments. By doing so, the effect of experimental treatment is evaluated. If the model simulation fits the data significantly better when model parameters are estimated for different treatments separately, effect of this treatment is significant.

The calibration of the models is not run within this document because it takes couple of hours to finish. Results of the previous iteration is printed instead. 
To run the code and reproduce the results, the option "eval" need to be changed to TRUE. Please note that the parallel computing is used. Number of cores is set to total number of cores of the computer minus 1. This can be changed if necessary. 

####Monod model
```{r monod model respiration, eval=F, echo=T}
monod_r<-function(data, FACT){
  
  #FACT 1 = Substrate, 2=Structure, 3=Both, 4=No
  
  if(FACT==1){
    
    dat<-data
    dat$id<-ifelse(data$Substrate=="Glucose", 1, 2)
    
  }else{
    
    if(FACT==2){
      
      dat<-data
      dat<-data
      ids<-dat %>% group_by(Structure) %>% summarise(id=n())
      ids$id<-seq(1:nrow(ids))
      
      dat<-merge(dat, ids, by.x=c("Structure"), by.y=c("Structure"))
      
    }else{
      
      if(FACT==3){
        
        dat<-data
        ids<-dat %>% group_by(Substrate, Structure) %>% summarise(id=n())
        ids$id<-seq(1:nrow(ids))
        
        dat<-merge(dat, ids, by.x=c("Substrate","Structure"), by.y=c("Substrate", "Structure"))
        
        
      }else{
        
        dat<-data
        dat$id<-c(1)
        
      }
    }
  }
  
  
    #monod growth function
    deriv<-function(time, state, pars){
      
      with(as.list(c(state, pars)),{
        
        dCmic<--k*Cmic+CUE*Vmax*Cmic*C/(Km+C)
        dC<-k*Cmic-Vmax*Cmic*C/(Km+C)
        
        return(list(c(dCmic, dC), r=(1-CUE)*Vmax*Cmic*C/(Km+C), Protc=0.548*Cmic))
        
      })
    }
    
    #define names of parameters
    parnames<-c("Vmax", "Km", "CUE", "k", "Cmic_0")
    
    #parameters estimation function
    estim<-function(odeset){
      
      #defining cost function
      cost<-function(x){
        
        par<-x[1:length(parnames)]
        
        names(par)<-parnames
        
        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(Cmic=par[["Cmic_0"]], C=25), parms=par, deriv, times=sort(odeset$Time)))
        
        #select time and the measured variables 
        yhat<-select(yhat_all, c("time", "r", "Protc"))
        
        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")
        
        #add the measured data to a data frame
        Yhat$obs<-c(odeset[order(odeset$Time), c("r")], odeset[order(odeset$Time), "Protc"])
        
        #add the weighting factor
        #I want to have the weighting factor to be proportional to mean of the given variable 
        yweights<-Yhat %>% group_by(variable) %>% summarise(weights=mean(value, na.rm = T))
        
        #match with the Yhat data frame
        Yhat<-merge(Yhat, yweights, by.x=c("variable"), by.y=c("variable"))
        
        Yhat<-Yhat[Yhat$variable!="Protc", ]
        
        #now, the root mean square error is calculated
        NRMSE<-as.numeric(Yhat %>% summarise(NRMSE=sum((((value-obs)/mean(weights))^2), na.rm = T)))
        
        return(NRMSE)
        
      }
      
      #defining goodness of fit function 
      rsq_ode<-function(x){
        
        par<-x[1:length(parnames)]
        
        names(par)<-parnames
        
        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(Cmic=par[["Cmic_0"]], C=25), parms=par, deriv, times=sort(odeset$Time)))
        
        #select time and the measured variables 
        yhat<-select(yhat_all, c("time", "r", "Protc"))
        
        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")
        
        #add the measured data to a data frame
        Yhat$obs<-c(odeset[order(odeset$Time), c("r")], odeset[order(odeset$Time), "Protc"])
        Yhat$Substrate<-rep(odeset[order(odeset$Time), "Substrate"], times=2)
        Yhat$Structure<-rep(odeset[order(odeset$Time), "Structure"], times=2)
        
        #rsquared calculation for each variable
        Gfit<-Yhat %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T), 
                                                        SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                        ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        Gfit$R2<-with(Gfit, 1-SSres/SStot)
        Gfit$N<-c(5)
        Gfit$AIC<-with(Gfit, 2*N-2*ll)
        
        rsq_out<-list(Yhat=Yhat, Gfit=Gfit)
        
        return(rsq_out)
        
      }
      
      #approximate parameter estimation is done by MCMC method
      par_mcmc<-modMCMC(f=cost, p=c(Vmax=0.1, Km=3, CUE=0.5, k=1e-3, Cmic_0=0.01), 
                        lower=c(Vmax=1e-6, Km=1e-3, CUE=0, k=1e-6, Cmic_0=0.0001),
                        upper=c(Vmax=10, Km=100, CUE=1, k=10, Cmic_0=10), niter=10000)
      
      #lower and upper limits for parameters are extracted
      pl<-summary(par_mcmc)["min",]
      pu<-summary(par_mcmc)["max",]
      
      #these limits are used to find global optimum by DEoptim
      opt_par<-DEoptim(fn=cost, lower=pl, upper=pu, 
                       control = c(itermax = 10000, steptol = 50, reltol = 1e-8, 
                                   trace=FALSE, strategy=3, NP=250))
      
      #global optimum parameters are further used in MCMC to find parameters distribution
      par_prof<-modMCMC(f=cost, p=opt_par$optim$bestmem, 
                        lower=pl,
                        upper=pu, niter=5000)
      
      #goodness of fit
      fit<-rsq_ode(opt_par$optim$bestmem)
      
      #best parameters
      p<-opt_par$optim$bestmem
      names(p)<-parnames
      
      #return list with opt_par and par_prof
      estim_out<-list(pars=p, par_prof=par_prof, fit=fit)
      
      return(estim_out)
      
    }
    
    
    #parameter estimation
    if(FACT==4){
      
      res<-vector("list", length = 1)
      res[[1]]<-estim(odeset=dat)
      
    }else{
      
      res<-foreach(i=unique(dat$id), .combine=list, .multicombine = TRUE,
                   .packages=c("FME", "dplyr", "DEoptim", "reshape")) %dopar% {
                     
                     estim(odeset=dat[dat$id==i,])
                     
                   }
    }
    
    
    #calculation of overall goodness of fit from individual results
    if(FACT==4){
      
      res$goodness<-res[[1]]$fit$Gfit
      res$OvP<-res[[1]]$fit$Yhat
      
    }else{
      
      if(FACT==1){
        
        res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat)
        
        #rsquared calculation for each variable
        res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T), 
                                                                   SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                   ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
        res$goodness$N<-rep(length(parnames)*2, times=2)
        res$goodness$AIC<-with(res$goodness, 2*N-2*ll)
        
        
      }else{
        
        if(FACT==2){
          
          res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat, res[[3]]$fit$Yhat)
          
          #rsquared calculation for each variable
          res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T), 
                                                                     SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                     ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
          res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
          res$goodness$N<-rep(length(parnames)*3, times=2)
          res$goodness$AIC<-with(res$goodness, 2*N-2*ll)
          
        }else{
          
          res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat, res[[3]]$fit$Yhat, res[[4]]$fit$Yhat, res[[5]]$fit$Yhat, res[[6]]$fit$Yhat)
          
          #rsquared calculation for each variable
          res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T), 
                                                                     SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                     ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
          res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
          res$goodness$N<-rep(length(parnames)*6, times=2)
          res$goodness$AIC<-with(res$goodness, 2*N-2*ll)
          
        }
        
      }
      
    }
    
    return(res)
    
    
}

```


```{r monod respiration calibration, eval=F, echo=T}
#across all treatments
monod_r1<-monod_r(data=d, FACT = 4)

no_cors<-detectCores()-1
cl<-makeCluster(no_cors)
registerDoParallel(cl)

#for different structures
monod_r2<-monod_r(data=d, FACT = 2)

#for different substrates
monod_r3<-monod_r(data=d, FACT = 1)

#for each separately 
monod_r4<-monod_r(data=d, FACT = 3)

stopImplicitCluster()

monod_r1$goodness
monod_r2$goodness
monod_r3$goodness
monod_r4$goodness
```

```{r monod respiration calibration results, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

#results of the previous iteration (not run)
# monod_r_results_par<-rbind(monod_r1[[1]]$pars,
#                        monod_r2[[1]]$pars, monod_r2[[2]]$pars, monod_r2[[3]]$pars,
#                        monod_r3[[1]]$pars, monod_r3[[2]]$pars,
#                        monod_r4[[1]]$pars, monod_r4[[2]]$pars, monod_r4[[3]]$pars,
#                        monod_r4[[4]]$pars, monod_r4[[5]]$pars, monod_r4[[6]]$pars)
# monod_r_results_good<-rbind(monod_r1$goodness[1,c(4:7)],
#                        monod_r2$goodness[1,c(4:7)],
#                        monod_r3$goodness[1,c(4:7)],
#                        monod_r4$goodness[1,c(4:7)])
# write.csv(monod_r_results_par, file = c("../monod_r_results_par.csv"), row.names = F)
# write.csv(monod_r_results_good, file = c("../monod_r_results_good.csv"), row.names = F)

monod_r_results_par<-read.csv("monod_r_results_par.csv")
monod_r_results_good<-read.csv("monod_r_results_good.csv")


t.s1.1<-data.frame(Vmax=monod_r_results_par[,1],
                 Km=monod_r_results_par[,2],
                 CUE=monod_r_results_par[,3],
                 k=monod_r_results_par[,4])
row.names(t.s1.1)<-c("All", "Broth", "Glass", "Wool",
                    "Cellobiose", "Glucose",
                    "Broth - Cellobiose", "Broth - Glucose",
                    "Glass - Cellobiose", "Glass - Glucose",
                    "Wool - Cellobiose", "Wool - Glucose")

options(knitr.kable.NA = '')


kable(t.s1.1, digits = c(2, 2, 2, 3), align = 'c', "html", booktabs=T, col.names = c('$\\V_{MAX}$', '$\\K_{M}$', 'CUE', '$\\k_{MB}$'), row.names=T, caption = "_**Table S3:** Monod model parameters calibrated against respiration rate across all treatments (All), for different levels of incubation system complexity separately (Structure), for Glucose and Celluloze treatments separately (Substrate), and for all experimental treatments separatelly (Each). See Materials and Methods for symbols explanation._") %>% 
  kable_styling() %>% 
  group_rows("All", 1, 1) %>%
  group_rows("Structure", 2, 4) %>%
  group_rows("Substrate", 5, 6) %>%
  group_rows("Each", 7, 12) 

kable(monod_r_results_good, digits = c(2, 2, 2, 2), align = 'c', "html", booktabs=T, col.names = c('Log Likelihood', '$\\R^{2}$', 'Number of parameters', 'AIC'), row.names=F, caption = "_**Table S4:** Goodness of fit of monod model calibrated against respiration rate across all treatments (All), for different levels of incubation system complexity separately (Structure), for Glucose and Celluloze treatments separately (Substrate), and for all experimental treatments separatelly (Each). See Materials and Methods for symbols explanation._") %>% 
  kable_styling() %>% 
  group_rows("All", 1, 1) %>%
  group_rows("Structure", 2, 2) %>%
  group_rows("Substrate", 3, 4) %>%
  group_rows("Each", 4, 4) 

```

####MEND model
```{r MEND model respiration, eval=F, echo=T}
mend_r<-function(data, FACT){
  
  #FACT 1 = Substrate, 2=Structure, 3=Both, 4=No
  
  if(FACT==1){
    
    dat<-data
    dat$id<-ifelse(d$Substrate=="Glucose", 1, 2)
    
  }else{
    
    if(FACT==2){
      
      dat<-data
      dat<-data
      ids<-dat %>% group_by(Structure) %>% summarise(id=n())
      ids$id<-seq(1:nrow(ids))
      
      dat<-merge(dat, ids, by.x=c("Structure"), by.y=c("Structure"))
      
    }else{
      
      if(FACT==3){
        
        dat<-data
        ids<-dat %>% group_by(Substrate, Structure) %>% summarise(id=n())
        ids$id<-seq(1:nrow(ids))
        
        dat<-merge(dat, ids, by.x=c("Substrate","Structure"), by.y=c("Substrate", "Structure"))
        
        
      }else{
        
        dat<-data
        dat$id<-c(1)
        
      }
    }
  }
  
    #mend model
    deriv<-function(time, state, pars){
      
      with(as.list(c(state, pars)),{
        
        #equations
        #C uptake
        Cu=Vmax*Cmic*C/(Km+C)
        #respiration
        r=mr*Cmic+(1-CUE)*Cu
        
        #Protc=Cmic*fp
        #DNAc=Cmic*fd
        
        #states
        dCmic<-CUE*Cu-mr*Cmic
        dC<--Cu
        
        return(list(c(dCmic, dC), r=r))
        
      })
    }
    #define names of parameters
    parnames<-c("Vmax", "Km", "CUE", "mr", "Cmic_0")
    
    #parameters estimation function
    estim<-function(odeset){
      
      #defining cost function
      cost<-function(x){
        
        par<-x[1:length(parnames)]
        
        names(par)<-parnames
        
        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(Cmic=par[["Cmic_0"]], C=25), parms=par, deriv, times=sort(odeset$Time)))
        
        #select time and the measured variables 
        yhat<-select(yhat_all, c("time", "r"))
        colnames(yhat)<-c("time", "value")
        
        #reformat to long format data frame
        #Yhat<-melt(yhat, id.vars = "time")
        
        #add the measured data to a data frame
        yhat$obs<-c(odeset[order(odeset$Time), c("r")])
        
        #add the weighting factor
        #I want to have the weighting factor to be proportional to mean of the given variable 
        yhat$weights<-rep(mean(yhat$value, na.rm = T), times=nrow(yhat))
        
        #match with the Yhat data frame
        #Yhat<-merge(Yhat, yweights, by.x=c("variable"), by.y=c("variable"))
        
        #Yhat<-Yhat[Yhat$variable!="Protc", ]
        
        #now, the root mean square error is calculated
        NRMSE<-with(yhat, sum((((value-obs)/mean(weights))^2), na.rm = T))
        
        return(NRMSE)
        
      }
      
      #defining goodness of fit function 
      rsq_ode<-function(x){
        
        par<-x[1:length(parnames)]
        
        names(par)<-parnames
        
        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(Cmic=par[["Cmic_0"]], C=25), parms=par, deriv, times=sort(odeset$Time)))
        
        #select time and the measured variables 
        yhat<-select(yhat_all, c("time", "r"))
        colnames(yhat)<-c("time", "value")
        
        #reformat to long format data frame
        #Yhat<-melt(yhat, id.vars = "time")
        
        #add the measured data to a data frame
        yhat$obs<-c(odeset[order(odeset$Time), c("r")])
        
        #add the weighting factor
        #I want to have the weighting factor to be proportional to mean of the given variable 
        #yhat$weights<-rep(mean(yhat$value, na.rm = T), times=nrow(yhat))
        
        #match with the Yhat data frame
        #Yhat<-merge(Yhat, yweights, by.x=c("variable"), by.y=c("variable"))
        
        #Yhat<-Yhat[Yhat$variable!="Protc", ]
        
        #rsquared calculation for each variable
        SSres=with(yhat, sum(((obs-value)^2), na.rm = T))
        SStot=with(yhat, sum(((obs-mean(obs, na.rm = T))^2), na.rm = T))
        ll=with(yhat, -sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        R2<-1-SSres/SStot
        N<-length(x)
        AIC<-2*N-2*ll
        
        Gfit<-c(R2=R2, N=N, AIC=AIC, ll=ll)
        
        rsq_out<-list(Yhat=yhat, Gfit=Gfit)
        
        return(rsq_out)
        
      }
      
      #approximate parameter estimation is done by MCMC method
      par_mcmc<-modMCMC(f=cost, p=c(Vmax=0.1, Km=3, CUE=0.5, mr=0.01, Cmic_0=0.01), 
                          lower=c(Vmax=1e-3, Km=1e-3, CUE=0, mr=1e-5, Cmic_0=1e-5),
                          upper=c(Vmax=10, Km=100, CUE=1, mr=10, Cmic_0=5), niter=10000)
      
      #lower and upper limits for parameters are extracted
      pl<-summary(par_mcmc)["min",]
      pu<-summary(par_mcmc)["max",]
      
      #these limits are used to find global optimum by DEoptim
      opt_par<-DEoptim(fn=cost, lower=pl, upper=pu, 
                       control = c(itermax = 10000, steptol = 50, reltol = 1e-8, 
                                   trace=FALSE, strategy=3, NP=250))
      
      #global optimum parameters are further used in MCMC to find parameters distribution
      par_prof<-modMCMC(f=cost, p=opt_par$optim$bestmem, 
                        lower=pl,
                        upper=pu, niter=5000)
      
      #goodness of fit
      fit<-rsq_ode(opt_par$optim$bestmem)
      
      #best parameters
      p<-opt_par$optim$bestmem
      names(p)<-parnames
      
      #return list with opt_par and par_prof
      estim_out<-list(pars=p, par_prof=par_prof, fit=fit)
      
      return(estim_out)
    
    }
    
    
    #parameter estimation
    if(FACT==4){
      
      res<-vector("list", length = 1)
      res[[1]]<-estim(odeset=dat)
      
    }else{
      
      res<-foreach(i=unique(dat$id), .combine=list, .multicombine = TRUE,
                   .packages=c("FME", "dplyr", "DEoptim", "reshape")) %dopar% {
                     
                     estim(odeset=dat[dat$id==i,])
                     
                   }
    }
    
    
    #calculation of overall goodness of fit from individual results
    if(FACT==4){
      
      res$goodness<-res[[1]]$fit$Gfit
      res$OvP<-res[[1]]$fit$Yhat
      
    }else{
      
      if(FACT==1){
        
        res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat)
        
        #rsquared calculation for each variable
        SSres=with(res$OvP, sum(((obs-value)^2), na.rm = T))
        SStot=with(res$OvP, sum(((obs-mean(obs, na.rm = T))^2), na.rm = T))
        ll=with(res$OvP, -sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        R2<-1-SSres/SStot
        N<-length(parnames)*2
        AIC<-2*N-2*ll
        
        res$goodness<-c(R2=R2, N=N, AIC=AIC, ll=ll)
        
      }else{
        
        if(FACT==2){
          
          res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat, res[[3]]$fit$Yhat)
          
        #rsquared calculation for each variable
        SSres=with(res$OvP, sum(((obs-value)^2), na.rm = T))
        SStot=with(res$OvP, sum(((obs-mean(obs, na.rm = T))^2), na.rm = T))
        ll=with(res$OvP, -sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        R2<-1-SSres/SStot
        N<-length(parnames)*3
        AIC<-2*N-2*ll
        
        res$goodness<-c(R2=R2, N=N, AIC=AIC, ll=ll)
          
        }else{
          
          res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat, res[[3]]$fit$Yhat, res[[4]]$fit$Yhat, res[[5]]$fit$Yhat, res[[6]]$fit$Yhat)
          
        #rsquared calculation for each variable
        SSres=with(res$OvP, sum(((obs-value)^2), na.rm = T))
        SStot=with(res$OvP, sum(((obs-mean(obs, na.rm = T))^2), na.rm = T))
        ll=with(res$OvP, -sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        R2<-1-SSres/SStot
        N<-length(parnames)*6
        AIC<-2*N-2*ll
        
        res$goodness<-c(R2=R2, N=N, AIC=AIC, ll=ll)
        }
        
      }
      
    }
    
  return(res)
  
}

```

```{r MEND respiration calibration, eval=F, echo=T}
#across all treatments
mend_r1<-mend_r(data=d, FACT = 4)

no_cors<-detectCores()-1
cl<-makeCluster(no_cors)
registerDoParallel(cl)

#for different structures
mend_r2<-mend_r(data=d, FACT = 2)

#for different substrates
mend_r3<-mend_r(data=d, FACT = 1)

#for each separately 
mend_r4<-mend_r(data=d, FACT = 3)

stopImplicitCluster()

mend_r1$goodness
mend_r2$goodness
mend_r3$goodness
mend_r4$goodness

```


```{r MEND respiration calibration results, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

# #results of the previous iteration (not run)
# mend_r_results_par<-rbind(mend_r1[[1]]$pars,
#                      mend_r2[[1]]$pars, mend_r2[[2]]$pars, mend_r2[[3]]$pars,
#                      mend_r3[[1]]$pars, mend_r3[[2]]$pars,
#                      mend_r4[[1]]$pars, mend_r4[[2]]$pars, mend_r4[[3]]$pars,
#                      mend_r4[[4]]$pars, mend_r4[[5]]$pars, mend_r4[[6]]$pars)
# mend_r_results_good<-as.data.frame(rbind(mend_r1$goodness,
#                     mend_r2$goodness,
#                     mend_r3$goodness,
#                     mend_r4$goodness))
# write.csv(mend_r_results_par, file = c("../mend_r_results_par.csv"), row.names = F)
# write.csv(mend_r_results_good, file = c("../mend_r_results_good.csv"), row.names = F)

mend_r_results_par<-read.csv("mend_r_results_par.csv")
mend_r_results_good<-read.csv("mend_r_results_good.csv")


t.s2.1<-data.frame(Vmax=mend_r_results_par[,1],
                 Km=mend_r_results_par[,2],
                 CUE=mend_r_results_par[,3],
                 mr=mend_r_results_par[,4])
row.names(t.s2.1)<-c("All", "Broth", "Glass", "Wool",
                    "Celluloze", "Glucose",
                    "Broth - Cellobiose", "Broth - Glucose",
                    "Glass - Cellobiose", "Glass - Glucose",
                    "Wool - Cellobiose", "Wool - Glucose")

options(knitr.kable.NA = '')


kable(t.s2.1, digits = c(2, 2, 2, 3), align = 'c', "html", booktabs=T, col.names = c('$\\V_{MAX}$', '$\\K_{M}$', 'CUE', '$\\m_{R}$'), row.names=T, caption = "_**Table S5:** MEND model parameters calibrated against respiration rate across all treatments (All), for different levels of incubation system complexity separately (Structure), for Glucose and Celluloze treatments separately (Substrate), and for all experimental treatments separatelly (Each). See Materials and Methods for symbols explanation._") %>% 
  kable_styling() %>% 
  group_rows("All", 1, 1) %>%
  group_rows("Structure", 2, 4) %>%
  group_rows("Substrate", 5, 6) %>%
  group_rows("Each", 7, 12) 

kable(mend_r_results_good, digits = c(2, 2, 2, 2), align = 'c', "html", booktabs=T, col.names = c('Log Likelihood', '$\\R^{2}$', 'Number of parameters', 'AIC'), row.names=F, caption = "_**Table S6:** Goodness of fit of MEND model calibrated against respiration rate across all treatments (All), for different levels of incubation system complexity separately (Structure), for Glucose and Celluloze treatments separately (Substrate), and for all experimental treatments separatelly (Each). See Materials and Methods for symbols explanation._") %>% 
  kable_styling() %>% 
  group_rows("All", 1, 1) %>%
  group_rows("Structure", 2, 2) %>%
  group_rows("Substrate", 3, 4) %>%
  group_rows("Each", 4, 4) 

```

####DEB model
```{r DEB model respiration, eval=F, echo=T}
deb_r<-function(data, FACT){

  #FACT 1 = Substrate, 2=Structure, 3=Both, 4=No


  #if factor needs to be included, its levels are defined
  if(FACT==1){

    dat<-data
    dat$id<-ifelse(data$Substrate=="Glucose", 1, 2)

  }else{

    if(FACT==2){

      dat<-data
      dat<-data
      ids<-dat %>% group_by(Structure) %>% summarise(id=n())
      ids$id<-seq(1:nrow(ids))

      dat<-merge(dat, ids, by.x=c("Structure"), by.y=c("Structure"))

    }else{

      if(FACT==3){

        dat<-data
        ids<-dat %>% group_by(Substrate, Structure) %>% summarise(id=n())
        ids$id<-seq(1:nrow(ids))

        dat<-merge(dat, ids, by.x=c("Substrate","Structure"), by.y=c("Substrate", "Structure"))


      }else{

        dat<-data
        dat$id<-c(1)

      }
    }
  }

    #deb model
    deriv<-function(time, state, pars){

      with(as.list(c(state, pars)),{

        #Carbon uptake
        Cu=Vmax*C*S/(Km+C)

        #maintnance
        m=S*m0

        #reserve mobilization rate for growth
        an=f*R-m

        #calibrated variables
        #protein abundance in reserves and structures is mean value reported
        #by Hanegraaf and Muller, 2001
        r=m+pmax(an*(1-Yu), 0)

        Protc=0.7095*S+0.6085*R
        #Protc=fps*S+fpr*R

        dR<-Cu-f*R
        dS<-pmax(an*Yu,0)+pmin(0, an)
        dC<--Cu


        return(list(c(dR, dS, dC), r=r, Protc=Protc))

      })
    }
    #define names of parameters
    parnames<-c("Vmax", "Km", "m0", "f", "Yu", "R_0", "S_0")

    #parameters estimation function
    estim<-function(odeset){

      #defining cost function
      cost<-function(x){

        par<-x[1:length(parnames)]

        names(par)<-parnames

        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(R=par[["R_0"]], S=par[["S_0"]], C=25), parms=par, deriv, times=sort(odeset$Time)))

        #select time and the measured variables
        yhat<-select(yhat_all, c("time", "r", "Protc"))

        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")

        #add the measured data to a data frame
        Yhat$obs<-c(odeset[order(odeset$Time), c("r")], odeset[order(odeset$Time), "Protc"])

        #add the weighting factor
        #I want to have the weighting factor to be proportional to mean of the given variable
        yweights<-Yhat %>% group_by(variable) %>% summarise(weights=mean(value, na.rm = T))

        #match with the Yhat data frame
        Yhat<-merge(Yhat, yweights, by.x=c("variable"), by.y=c("variable"))

        Yhat<-Yhat[Yhat$variable!="Protc", ]

        #now, the root mean square error is calculated
        NRMSE<-as.numeric(Yhat %>% summarise(NRMSE=sum((((value-obs)/mean(weights))^2), na.rm = T)))

        return(NRMSE)

      }

      #defining goodness of fit function
      rsq_ode<-function(x){

        par<-x[1:length(parnames)]

        names(par)<-parnames

        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(R=par[["R_0"]], S=par[["S_0"]], C=25), parms=par, deriv, times=sort(odeset$Time)))

        #select time and the measured variables
        yhat<-select(yhat_all, c("time", "r", "Protc"))

        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")

        #add the measured data to a data frame
        Yhat$obs<-c(odeset[order(odeset$Time), c("r")], odeset[order(odeset$Time), "Protc"])
        Yhat$Substrate<-rep(odeset[order(odeset$Time), "Substrate"], times=2)
        Yhat$Structure<-rep(odeset[order(odeset$Time), "Structure"], times=2)

        #rsquared calculation for each variable
        Gfit<-Yhat %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T),
                                                        SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                        ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        Gfit$R2<-with(Gfit, 1-SSres/SStot)
        Gfit$N<-c(7)
        Gfit$AIC<-with(Gfit, 2*N-2*ll)

        rsq_out<-list(Yhat=Yhat, Gfit=Gfit)

        return(rsq_out)

      }

      #approximate parameter estimation is done by MCMC method
      par_mcmc<-modMCMC(f=cost, p=c(Vmax=0.1, Km=3, m0=0.01, f=4, Yu=0.8,R_0=0.03483481, S_0=0.07661063),
                          lower=c(Vmax=1e-5, Km=1e-2, m0=1e-5, f=1e-3, Yu=0.01, R_0=1e-4, S_0=1e-4),
                          upper=c(Vmax=1, Km=20, m0=1, f=100, Yu=0.8, R_0=2, S_0=2), niter=10000)

      #lower and upper limits for parameters are extracted
      pl<-summary(par_mcmc)["min",]
      pu<-summary(par_mcmc)["max",]

      #these limits are used to find global optimum by DEoptim
      opt_par<-DEoptim(fn=cost, lower=pl, upper=pu,
                       control = c(itermax = 10000, steptol = 50, reltol = 1e-8,
                                   trace=FALSE, strategy=3, NP=250))

      #global optimum parameters are further used in MCMC to find parameters distribution
      par_prof<-modMCMC(f=cost, p=opt_par$optim$bestmem,
                        lower=pl,
                        upper=pu, niter=5000)

      #goodness of fit
      fit<-rsq_ode(opt_par$optim$bestmem)

      #best parameters
      p<-opt_par$optim$bestmem
      names(p)<-parnames

      #return list with opt_par and par_prof
      estim_out<-list(pars=p, par_prof=par_prof, fit=fit)

      return(estim_out)

    }


    #parameter estimation
    if(FACT==4){

      res<-vector("list", length = 1)
      res[[1]]<-estim(odeset=dat)

    }else{

      res<-foreach(i=unique(dat$id), .combine=list, .multicombine = TRUE,
                   .packages=c("FME", "dplyr", "DEoptim", "reshape")) %dopar% {

                     estim(odeset=dat[dat$id==i,])

                   }
    }


    #calculation of overall goodness of fit from individual results
    if(FACT==4){

      res$goodness<-res[[1]]$fit$Gfit
      res$OvP<-res[[1]]$fit$Yhat

    }else{

      if(FACT==1){

        res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat)

        #rsquared calculation for each variable
        res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T),
                                                               SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                               ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
        res$goodness$N<-rep(length(parnames)*2, times=2)
        res$goodness$AIC<-with(res$goodness, 2*N-2*ll)


      }else{

        if(FACT==2){

          res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat, res[[3]]$fit$Yhat)

          #rsquared calculation for each variable
          res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T),
                                                                 SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                 ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
          res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
          res$goodness$N<-rep(length(parnames)*3, times=2)
          res$goodness$AIC<-with(res$goodness, 2*N-2*ll)

        }else{

          res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat, res[[3]]$fit$Yhat, res[[4]]$fit$Yhat, res[[5]]$fit$Yhat, res[[6]]$fit$Yhat)

          #rsquared calculation for each variable
          res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T),
                                                                 SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                 ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
          res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
          res$goodness$N<-rep(length(parnames)*6, times=2)
          res$goodness$AIC<-with(res$goodness, 2*N-2*ll)

        }

      }

    }

  return(res)

}

```

```{r DEB respiration calibration, eval=F, echo=T}

#across all treatments
deb_r1<-deb_r(data=d, FACT = 4)

no_cors<-detectCores()-1
cl<-makeCluster(no_cors)
registerDoParallel(cl)

#for different structures
deb_r2<-deb_r(data=d, FACT = 2)

#for different substrates
deb_r3<-deb_r(data=d, FACT = 1)

#for each separately 
deb_r4<-deb_r(data=d, FACT = 3)

stopImplicitCluster()

deb_r1$goodness
deb_r2$goodness
deb_r3$goodness
deb_r4$goodness

```

```{r DEB respiration calibration results, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

#results of the previous iteration (not run)
# deb_r_results_par<-rbind(deb_r1[[1]]$pars,
#                      deb_r2[[1]]$pars, deb_r2[[2]]$pars, deb_r2[[3]]$pars,
#                      deb_r3[[1]]$pars, deb_r3[[2]]$pars,
#                      deb_r4[[1]]$pars, deb_r4[[2]]$pars, deb_r4[[3]]$pars,
#                      deb_r4[[4]]$pars, deb_r4[[5]]$pars, deb_r4[[6]]$pars)
# deb_r_results_good<-rbind(deb_r1$goodness[1,c(4:7)],
#                    deb_r2$goodness[1,c(4:7)],
#                    deb_r3$goodness[1,c(4:7)],
#                    deb_r4$goodness[1,c(4:7)])
# write.csv(deb_r_results_par, file = c("../deb_r_results_par.csv"), row.names = F)
# write.csv(deb_r_results_good, file = c("../deb_r_results_good.csv"), row.names = F)

deb_r_results_par<-read.csv("deb_r_results_par.csv")
deb_r_results_good<-read.csv("deb_r_results_good.csv")


t.s3.1<-data.frame(Vmax=deb_r_results_par[,1],
                 Km=deb_r_results_par[,2],
                 mo=deb_r_results_par[,3],
                 f=deb_r_results_par[,4],
                 Yu=deb_r_results_par[,5])
row.names(t.s3.1)<-c("All", "Broth", "Glass", "Wool",
                    "Cellobiose", "Glucose",
                    "Broth - Cellobiose", "Broth - Glucose",
                    "Glass - Cellobiose", "Glass - Glucose",
                    "Wool - Cellobiose", "Wool - Glucose")

options(knitr.kable.NA = '')


kable(t.s3.1, digits = c(2, 2, 3, 2, 2), align = 'c', "html", booktabs=T, col.names = c('$\\V_{MAX}$', '$\\K_{M}$', '$\\m_{R}$', '$\\f_{0}$', '$\\Y_{S}$'), row.names=T, caption = "_**Table S7:** DEB model parameters calibrated against respiration rate across all treatments (All), for different levels of incubation system complexity separately (Structure), for Glucose and Celluloze treatments separately (Substrate), and for all experimental treatments separatelly (Each). See Materials and Methods for symbols explanation._") %>% 
  kable_styling() %>% 
  group_rows("All", 1, 1) %>%
  group_rows("Structure", 2, 4) %>%
  group_rows("Substrate", 5, 6) %>%
  group_rows("Each", 7, 12) 

kable(deb_r_results_good, digits = c(2, 2, 2, 2), align = 'c', "html", booktabs=T, col.names = c('Log Likelihood', '$\\R^{2}$', 'Number of parameters', 'AIC'), row.names=F, caption = "_**Table S8:** Goodness of fit of DEB model calibrated against respiration rate across all treatments (All), for different levels of incubation system complexity separately (Structure), for Glucose and Celluloze treatments separately (Substrate), and for all experimental treatments separatelly (Each). See Materials and Methods for symbols explanation._") %>% 
  kable_styling() %>% 
  group_rows("All", 1, 1) %>%
  group_rows("Structure", 2, 2) %>%
  group_rows("Substrate", 3, 4) %>%
  group_rows("Each", 4, 4) 

```

###All models are calibrated against respiration rate, proteins and DNA concentration
The calibration is done the same way as before. In addition to model parameters, the conversion factors between $C_{MB}$ (Monod and MEND model), $R$, $S$ (DEB model) and protein/DNA concetration are estimated. This is done for two reasons. First, conversion factors reported in literature vary widely. Second, using the mean or median of all reported conversion factors do not simulate $C_{MB}$, $R$ and $S$ dynamic accuratelly (data not shown).
There is one important difference between Monod/MEND model and DEB model. Temporal dynamic of Proteins and DNA concentration is different (see Fig. 2 of the main text) suggesting the variable composition of microbial biomass. Monod and MEND models do not account for this variability and thus, conversion factor have to be a fixed value. However, model parameters can theoretically compansate for the variability in microbial biomass composition but only if the model is calibrated against protein or DNA separately. Becuase the temporal dynamic of protein and DNA is different, the compensation have to occur differently. In contrast, DEB model account for the biomass composition variability explicitely and therefore, it can be calibrated against protein and DNA concentration at the same time. The following code reflects this difference.
Note that the calibration against respiration rate and protein/DNA concentration at the same time lead to a decrease of the the correspondence between Monod/MEND model respiration rate simulation and observations in several instances.


####Monod model
```{r monod model, eval=F, echo=T}
#######################################Proteins#############################################
monod_i<-function(data, FACT){
  
  #FACT 1 = Substrate, 2=Structure, 3=Both, 4=No
  
  if(FACT==1){
    
    dat<-data
    dat$id<-ifelse(data$Substrate=="Glucose", 1, 2)
    
  }else{
    
    if(FACT==2){
      
      dat<-data
      dat<-data
      ids<-dat %>% group_by(Structure) %>% summarise(id=n())
      ids$id<-seq(1:nrow(ids))
      
      dat<-merge(dat, ids, by.x=c("Structure"), by.y=c("Structure"))
      
    }else{
      
      if(FACT==3){
        
        dat<-data
        ids<-dat %>% group_by(Substrate, Structure) %>% summarise(id=n())
        ids$id<-seq(1:nrow(ids))
        
        dat<-merge(dat, ids, by.x=c("Substrate","Structure"), by.y=c("Substrate", "Structure"))
        
        
      }else{
        
        dat<-data
        dat$id<-c(1)
        
      }
    }
  }
  
  
    #monod growth function
    deriv<-function(time, state, pars){
      
      with(as.list(c(state, pars)),{
        
        Protc=fp*Cmic
        
        dCmic<--k*Cmic+CUE*Vmax*Cmic*C/(Km+C)
        dC<-k*Cmic-Vmax*Cmic*C/(Km+C)
        
        return(list(c(dCmic, dC), r=(1-CUE)*Vmax*Cmic*C/(Km+C), Protc=Protc))
        
      })
    }
    
    #define names of parameters
    parnames<-c("Vmax", "Km", "CUE", "k", "fp", "Cmic_0")
    
    #parameters estimation function
    estim<-function(odeset){
      
      #defining cost function
      cost<-function(x){
        
        par<-x[1:length(parnames)]
        
        names(par)<-parnames
        
        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(Cmic=par[["Cmic_0"]], C=25), parms=par, deriv, times=sort(odeset$Time)))
        
        #select time and the measured variables 
        yhat<-select(yhat_all, c("time", "r", "Protc"))
        
        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")
        
        #add the measured data to a data frame
        Yhat$obs<-c(odeset[order(odeset$Time), c("r")], odeset[order(odeset$Time), "Protc"])
        
        #add the weighting factor
        #I want to have the weighting factor to be proportional to mean of the given variable 
        yweights<-Yhat %>% group_by(variable) %>% summarise(weights=mean(value, na.rm = T))
        
        #match with the Yhat data frame
        Yhat<-merge(Yhat, yweights, by.x=c("variable"), by.y=c("variable"))
        
        #now, the root mean square error is calculated
        NRMSE<-as.numeric(Yhat %>% group_by(variable) %>% summarise(NRMSE=sum((((value-obs)/mean(weights))^2), na.rm = T)) %>% 
                            summarise(NRMSE=sum(NRMSE)))
        
        return(NRMSE)
        
      }
      
      #defining goodness of fit function 
      rsq_ode<-function(x){
        
        par<-x[1:length(parnames)]
        
        names(par)<-parnames
        
        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(Cmic=par[["Cmic_0"]], C=25), parms=par, deriv, times=sort(odeset$Time)))
        
        #select time and the measured variables 
        yhat<-select(yhat_all, c("time", "r", "Protc"))
        
        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")
        
        #add the measured data to a data frame
        Yhat$obs<-c(odeset[order(odeset$Time), c("r")], odeset[order(odeset$Time), "Protc"])
        Yhat$Substrate<-rep(odeset[order(odeset$Time), "Substrate"], times=2)
        Yhat$Structure<-rep(odeset[order(odeset$Time), "Structure"], times=2)
        
        #rsquared calculation for each variable
        Gfit<-Yhat %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T), 
                                                        SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                        ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        Gfit$R2<-with(Gfit, 1-SSres/SStot)
        Gfit$N<-length(x)
        Gfit$AIC<-with(Gfit, 2*N-2*ll)
        
        rsq_out<-list(Yhat=Yhat, Gfit=Gfit)
        
        return(rsq_out)
        
      }
      
      #approximate parameter estimation is done by MCMC method
      par_mcmc<-modMCMC(f=cost, p=c(Vmax=0.1, Km=3, CUE=0.5, k=1e-3, fp=0.5, Cmic_0=0.01), 
                        lower=c(Vmax=1e-6, Km=1e-3, CUE=0, k=1e-6, fp=0, Cmic_0=0.0001),
                        upper=c(Vmax=10, Km=100, CUE=1, k=10, fp=1, Cmic_0=10), niter=10000)
      
      #lower and upper limits for parameters are extracted
      pl<-summary(par_mcmc)["min",]
      pu<-summary(par_mcmc)["max",]
      
      #these limits are used to find global optimum by DEoptim
      opt_par<-DEoptim(fn=cost, lower=pl, upper=pu, 
                       control = c(itermax = 10000, steptol = 50, reltol = 1e-8, 
                                   trace=FALSE, strategy=3, NP=250))
      
      #global optimum parameters are further used in MCMC to find parameters distribution
      par_prof<-modMCMC(f=cost, p=opt_par$optim$bestmem, 
                        lower=pl,
                        upper=pu, niter=5000)
      
      #goodness of fit
      fit<-rsq_ode(opt_par$optim$bestmem)
      
      #best parameters
      p<-opt_par$optim$bestmem
      names(p)<-parnames
      
      #return list with opt_par and par_prof
      estim_out<-list(pars=p, par_prof=par_prof, fit=fit)
      
      return(estim_out)
      
    }
    
    
    #parameter estimation
    if(FACT==4){
      
      res<-vector("list", length = 1)
      res[[1]]<-estim(odeset=dat)
      
    }else{
      
      res<-foreach(i=unique(dat$id), .combine=list, .multicombine = TRUE,
                   .packages=c("FME", "dplyr", "DEoptim", "reshape")) %dopar% {
                     
                     estim(odeset=dat[dat$id==i,])
                     
                   }
    }
    
    
    #calculation of overall goodness of fit from individual results
    if(FACT==4){
      
      res$goodness<-res[[1]]$fit$Gfit
      res$OvP<-res[[1]]$fit$Yhat
      
    }else{
      
      if(FACT==1){
        
        res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat)
        
        #rsquared calculation for each variable
        res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T), 
                                                                   SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                   ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
        res$goodness$N<-rep(length(parnames)*2, times=2)
        res$goodness$AIC<-with(res$goodness, 2*N-2*ll)
        
        
      }else{
        
        if(FACT==2){
          
          res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat, res[[3]]$fit$Yhat)
          
          #rsquared calculation for each variable
          res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T), 
                                                                     SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                     ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
          res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
          res$goodness$N<-rep(length(parnames)*3, times=2)
          res$goodness$AIC<-with(res$goodness, 2*N-2*ll)
          
        }else{
          
          res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat, res[[3]]$fit$Yhat, res[[4]]$fit$Yhat, res[[5]]$fit$Yhat, res[[6]]$fit$Yhat)
          
          #rsquared calculation for each variable
          res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T), 
                                                                     SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                     ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
          res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
          res$goodness$N<-rep(length(parnames)*6, times=2)
          res$goodness$AIC<-with(res$goodness, 2*N-2*ll)
          
        }
        
      }
      
    }
    
    return(res)
}

##########################################DNA###########################################
###monod growth function
monod_i_DNA<-function(data, FACT){

  #FACT 1 = Substrate, 2=Structure, 3=Both, 4=No

  if(FACT==1){

    dat<-data
    dat$id<-ifelse(data$Substrate=="Glucose", 1, 2)

  }else{

    if(FACT==2){

      dat<-data
      dat<-data
      ids<-dat %>% group_by(Structure) %>% summarise(id=n())
      ids$id<-seq(1:nrow(ids))

      dat<-merge(dat, ids, by.x=c("Structure"), by.y=c("Structure"))

    }else{

      if(FACT==3){

        dat<-data
        ids<-dat %>% group_by(Substrate, Structure) %>% summarise(id=n())
        ids$id<-seq(1:nrow(ids))

        dat<-merge(dat, ids, by.x=c("Substrate","Structure"), by.y=c("Substrate", "Structure"))


      }else{

        dat<-data
        dat$id<-c(1)

      }
    }
  }


    #monod growth function
    deriv<-function(time, state, pars){

      with(as.list(c(state, pars)),{

        DNAc=fd*Cmic

        dCmic<--k*Cmic+CUE*Vmax*Cmic*C/(Km+C)
        dC<-k*Cmic-Vmax*Cmic*C/(Km+C)

        return(list(c(dCmic, dC), r=(1-CUE)*Vmax*Cmic*C/(Km+C), DNAc=DNAc))

      })
    }

    #define names of parameters
    parnames<-c("Vmax", "Km", "CUE", "k", "fd", "Cmic_0")

    #parameters estimation function
    estim<-function(odeset){

      #defining cost function
      cost<-function(x){

        par<-x[1:length(parnames)]

        names(par)<-parnames

        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(Cmic=par[["Cmic_0"]], C=25), parms=par, deriv, times=sort(odeset$Time)))

        #select time and the measured variables
        yhat<-select(yhat_all, c("time", "r", "DNAc"))

        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")

        #add the measured data to a data frame
        Yhat$obs<-c(odeset[order(odeset$Time), c("r")], odeset[order(odeset$Time), "DNAc"])

        #add the weighting factor
        #I want to have the weighting factor to be proportional to mean of the given variable
        yweights<-Yhat %>% group_by(variable) %>% summarise(weights=mean(value, na.rm = T))

        #match with the Yhat data frame
        Yhat<-merge(Yhat, yweights, by.x=c("variable"), by.y=c("variable"))

        #now, the root mean square error is calculated
        NRMSE<-as.numeric(Yhat %>% group_by(variable) %>% summarise(NRMSE=sum((((value-obs)/mean(weights))^2), na.rm = T)) %>%
                            summarise(NRMSE=sum(NRMSE)))

        return(NRMSE)

      }

      #defining goodness of fit function
      rsq_ode<-function(x){

        par<-x[1:length(parnames)]

        names(par)<-parnames

        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(Cmic=par[["Cmic_0"]], C=25), parms=par, deriv, times=sort(odeset$Time)))

        #select time and the measured variables
        yhat<-select(yhat_all, c("time", "r", "DNAc"))

        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")

        #add the measured data to a data frame
        Yhat$obs<-c(odeset[order(odeset$Time), c("r")], odeset[order(odeset$Time), "DNAc"])
        Yhat$Substrate<-rep(odeset[order(odeset$Time), "Substrate"], times=2)
        Yhat$Structure<-rep(odeset[order(odeset$Time), "Structure"], times=2)

        #rsquared calculation for each variable
        Gfit<-Yhat %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T),
                                                        SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                        ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        Gfit$R2<-with(Gfit, 1-SSres/SStot)
        Gfit$N<-c(6)
        Gfit$AIC<-with(Gfit, 2*N-2*ll)

        rsq_out<-list(Yhat=Yhat, Gfit=Gfit)

        return(rsq_out)

      }

      #approximate parameter estimation is done by MCMC method
      par_mcmc<-modMCMC(f=cost, p=c(Vmax=0.1, Km=3, CUE=0.5, k=1e-3, fp=0.5, Cmic_0=0.01),
                        lower=c(Vmax=1e-6, Km=1e-3, CUE=0, k=1e-6, fp=0, Cmic_0=0.0001),
                        upper=c(Vmax=10, Km=100, CUE=1, k=10, fp=1, Cmic_0=10), niter=10000)

      #lower and upper limits for parameters are extracted
      pl<-summary(par_mcmc)["min",]
      pu<-summary(par_mcmc)["max",]

      #these limits are used to find global optimum by DEoptim
      opt_par<-DEoptim(fn=cost, lower=pl, upper=pu,
                       control = c(itermax = 10000, steptol = 50, reltol = 1e-8,
                                   trace=FALSE, strategy=3, NP=250))

      #global optimum parameters are further used in MCMC to find parameters distribution
      par_prof<-modMCMC(f=cost, p=opt_par$optim$bestmem,
                        lower=pl,
                        upper=pu, niter=5000)

      #goodness of fit
      fit<-rsq_ode(opt_par$optim$bestmem)

      #best parameters
      p<-opt_par$optim$bestmem
      names(p)<-parnames

      #return list with opt_par and par_prof
      estim_out<-list(pars=p, par_prof=par_prof, fit=fit)

      return(estim_out)

    }


    #parameter estimation
    if(FACT==4){

      res<-vector("list", length = 1)
      res[[1]]<-estim(odeset=dat)

    }else{

      res<-foreach(i=unique(dat$id), .combine=list, .multicombine = TRUE,
                   .packages=c("FME", "dplyr", "DEoptim", "reshape")) %dopar% {

                     estim(odeset=dat[dat$id==i,])

                   }
    }


    #calculation of overall goodness of fit from individual results
    if(FACT==4){

      res$goodness<-res[[1]]$fit$Gfit
      res$OvP<-res[[1]]$fit$Yhat

    }else{

      if(FACT==1){

        res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat)

        #rsquared calculation for each variable
        res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T),
                                                                   SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                   ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
        res$goodness$N<-rep(length(parnames)*2, times=2)
        res$goodness$AIC<-with(res$goodness, 2*N-2*ll)


      }else{

        if(FACT==2){

          res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat, res[[3]]$fit$Yhat)

          #rsquared calculation for each variable
          res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T),
                                                                     SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                     ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
          res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
          res$goodness$N<-rep(length(parnames)*3, times=2)
          res$goodness$AIC<-with(res$goodness, 2*N-2*ll)

        }else{

          res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat, res[[3]]$fit$Yhat, res[[4]]$fit$Yhat, res[[5]]$fit$Yhat, res[[6]]$fit$Yhat)

          #rsquared calculation for each variable
          res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T),
                                                                     SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                     ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
          res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
          res$goodness$N<-rep(length(parnames)*6, times=2)
          res$goodness$AIC<-with(res$goodness, 2*N-2*ll)

        }

      }

    }

    return(res)
}

```

```{r, eval=F, echo=T}
#Proteins
#across all treatments
monod_i1<-monod_i(data=d, FACT = 4)

no_cors<-detectCores()-1
cl<-makeCluster(no_cors)
registerDoParallel(cl)

#for different structures
monod_i2<-monod_i(data=d, FACT = 2)

#for different substrates
monod_i3<-monod_i(data=d, FACT = 1)

#for each separately 
monod_i4<-monod_i(data=d, FACT = 3)

stopImplicitCluster()

monod_i1$goodness
monod_i2$goodness
monod_i3$goodness
monod_i4$goodness

#DNA
#across all treatments
monod_i1_DNA<-monod_i(data=d, FACT = 4)

no_cors<-detectCores()-1
cl<-makeCluster(no_cors)
registerDoParallel(cl)

#for different structures
monod_i2_DNA<-monod_i_DNA(data=d, FACT = 2)

#the initial Cmb concentration is estimated for each treatment separately
#the following code is run with the fixed initial Cmb concentration 
#across treatments (observed mean)
#this is done only with instances in which the model simulation can explain more than 0% 
#of the variability in protein and/or DNA dynamic  
monod_i2_DNA_fixed<-monod_i_DNA_fixed(data=d, FACT = 2)

#for different substrates
monod_i3_DNA<-monod_i_DNA(data=d, FACT = 1)

#for each separately 
monod_i4_DNA<-monod_i_DNA(data=d, FACT = 3)

stopImplicitCluster()

monod_i1_DNA$goodness
monod_i2_DNA$goodness
monod_i3_DNA$goodness
monod_i4_DNA$goodness

```

```{r Monod overall calibration results, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

#results of the previous iteration (not run)
# monod_all_results_par<-rbind(monod_i1[[1]]$pars, monod_i1_DNA[[1]]$pars,
#                     monod_i2[[1]]$pars, monod_i2[[2]]$pars, monod_i2[[3]]$pars,
#                     monod_i2_DNA_fixed[[1]]$pars, monod_i2_DNA_fixed[[2]]$pars, monod_i2_DNA_fixed[[3]]$pars,
#                     monod_i3[[1]]$pars, monod_i3[[2]]$pars,
#                     monod_i3_DNA[[1]]$pars, monod_i3_DNA[[2]]$pars,
#                     monod_i4[[1]]$pars, monod_i4[[2]]$pars, monod_i4[[3]]$pars,
#                     monod_i4[[4]]$pars, monod_i4[[5]]$pars, monod_i4[[6]]$pars,
#                     monod_i4_DNA[[1]]$pars, monod_i4_DNA[[2]]$pars, monod_i4_DNA[[3]]$pars,
#                     monod_i4_DNA[[4]]$pars, monod_i4_DNA[[5]]$pars, monod_i4_DNA[[6]]$pars)
# 
# monod_all_results_good<-rbind(monod_i1$goodness[,c(4:7)],
#                   monod_i2$goodness[,c(4:7)],
#                   monod_i3$goodness[,c(4:7)],
#                   monod_i4$goodness[,c(4:7)],
#                   monod_i1_DNA$goodness[,c(4:7)],
#                   monod_i2_DNA_fixed$goodness[,c(4:7)],
#                   monod_i3_DNA$goodness[,c(4:7)],
#                   monod_i4_DNA$goodness[,c(4:7)])
# 
# monod_all_results_good[monod_all_results_good$R2<0,"R2"]<-c(0)
# monod_all_results_good$Name<-c(rep(c("Respiration rate", "Protein"), times=4),
#                                rep(c("Respiration rate", "DNA"), times=4))
# monod_all_results_good<-monod_all_results_good[,c(5,1,2,3,4)]
# 
# 
# write.csv(monod_all_results_par, file = c("../monod_all_results_par.csv"), row.names = F)
# write.csv(monod_all_results_good, file = c("../monod_all_results_good.csv"), row.names = F)

monod_all_results_par<-read.csv("monod_all_results_par.csv")
monod_all_results_good<-read.csv("monod_all_results_good.csv")


t.s4.1<-data.frame(Name=rep(c("All", "Broth", "Glass", "Wool",
                    "Cellobiose", "Glucose",
                    "Broth - Cellobiose", "Broth - Glucose",
                    "Glass - Cellobiose", "Glass - Glucose",
                    "Wool - Cellobiose", "Wool - Glucose"), each =2),
                   Parameter=rep(c("Protein", "DNA"), times=12),
                   Vmax=monod_all_results_par[,1],
                   Km=monod_all_results_par[,2],
                   CUE=monod_all_results_par[,3],
                   k=monod_all_results_par[,4],
                   conv=monod_all_results_par[,5])

options(knitr.kable.NA = '')


kable(t.s4.1, digits = c(0, 0, 2, 2, 2, 3, 3), align = 'c', "html", booktabs=T, col.names = c(" "," ", '$\\V_{MAX}$', '$\\K_{M}$', 'CUE', '$\\k_{MB}$', 'Conversion factor'), row.names=F, caption = "_**Table S9:** Monod model parameters calibrated against respiration rate and protein/DNA concentration across all treatments (All), for different levels of incubation system complexity separately (Structure), for Glucose and Celluloze treatments separately (Substrate), and for all experimental treatments separatelly (Each). See Materials and Methods for symbols explanation._") %>% 
  kable_styling() %>% 
  group_rows("All", 1, 2) %>%
  group_rows("Structure", 3, 8) %>%
  group_rows("Substrate", 9, 12) %>%
  group_rows("Each", 13, 24) 

kable(monod_all_results_good, digits = c(0, 2, 2, 2, 2), align = 'c', "html", booktabs=T, col.names = c(" " , 'Log Likelihood', '$\\R^{2}$', 'Number of parameters', 'AIC'), row.names=F, caption = "_**Table S10:** Goodness of fit of Monod model calibrated against respiration rate and protein/DNA concentration across all treatments (All), for different levels of incubation system complexity separately (Structure), for Glucose and Celluloze treatments separately (Substrate), and for all experimental treatments separatelly (Each). See Materials and Methods for symbols explanation._") %>% 
  kable_styling() %>% 
  group_rows("Protein", 1, 8, label_row_css = "background-color: #666; color: #fff;") %>%
  group_rows("All", 1, 2) %>%
  group_rows("Structure", 3, 4) %>%
  group_rows("Substrate", 5, 6) %>%
  group_rows("Each", 7, 8) %>%
  group_rows("DNA", 9, 16, label_row_css = "background-color: #666; color: #fff;") %>%
  group_rows("All", 9, 10) %>%
  group_rows("Structure",11, 12) %>%
  group_rows("Substrate", 13, 14) %>%
  group_rows("Each", 15, 16) 

```

####Mend model
```{r MEND model, eval=F, echo=T}
############################################Protein############################################
mend_i<-function(data, FACT){
  
  #FACT 1 = Substrate, 2=Structure, 3=Both, 4=No
  
  if(FACT==1){
    
    dat<-data
    dat$id<-ifelse(d$Substrate=="Glucose", 1, 2)
    
  }else{
    
    if(FACT==2){
      
      dat<-data
      dat<-data
      ids<-dat %>% group_by(Structure) %>% summarise(id=n())
      ids$id<-seq(1:nrow(ids))
      
      dat<-merge(dat, ids, by.x=c("Structure"), by.y=c("Structure"))
      
    }else{
      
      if(FACT==3){
        
        dat<-data
        ids<-dat %>% group_by(Substrate, Structure) %>% summarise(id=n())
        ids$id<-seq(1:nrow(ids))
        
        dat<-merge(dat, ids, by.x=c("Substrate","Structure"), by.y=c("Substrate", "Structure"))
        
        
      }else{
        
        dat<-data
        dat$id<-c(1)
        
      }
    }
  }
  
    #mend model
    deriv<-function(time, state, pars){
      
      with(as.list(c(state, pars)),{
        
        #equations
        #C uptake
        Cu=Vmax*Cmic*C/(Km+C)
        #respiration
        r=mr*Cmic+(1-CUE)*Cu
        
        Protc=Cmic*fp
        #DNAc=Cmic*fd
        
        #states
        dCmic<-CUE*Cu-mr*Cmic
        dC<--Cu
        
        return(list(c(dCmic, dC), r=r, Protc=Protc))
        
        
      })
    }
    #define names of parameters
    parnames<-c("Vmax", "Km", "CUE", "mr", "fp", "Cmic_0")
    
    #parameters estimation function
    estim<-function(odeset){
      
      #defining cost function
      cost<-function(x){
        
        par<-x[1:length(parnames)]
        
        names(par)<-parnames
        
        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(Cmic=par[["Cmic_0"]], C=25), parms=par, deriv, times=sort(odeset$Time)))
        
        #select time and the measured variables 
        yhat<-select(yhat_all, c("time", "Protc", "r"))
        
        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")
        
        #add the measured data to a data frame
        Yhat$obs<-c(odeset[order(odeset$Time), "Protc"], odeset[order(odeset$Time), c("r")])
        
        #add the weighting factor
        #I want to have the weighting factor to be proportional to mean of the given variable 
        yweights<-Yhat %>% group_by(variable) %>% summarise(weights=mean(value, na.rm = T))
        
        #match with the Yhat data frame
        Yhat<-merge(Yhat, yweights, by.x=c("variable"), by.y=c("variable"))
        
        #now, the root mean square error is calculated
        NRMSE<-as.numeric(Yhat %>% group_by(variable) %>% summarise(NRMSE=sum((((value-obs)/mean(weights))^2), na.rm = T)) %>% 
                            summarise(NRMSE=sum(NRMSE)))
        
        return(NRMSE)
        
      }
      
      #defining goodness of fit function 
      rsq_ode<-function(x){
        
        par<-x[1:length(parnames)]
        
        names(par)<-parnames
        
        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(Cmic=par[["Cmic_0"]], C=25), parms=par, deriv, times=sort(odeset$Time)))
        
        #select time and the measured variables 
        yhat<-select(yhat_all, c("time", "Protc", "r"))
        
        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")
        
        #add the measured data to a data frame
        Yhat$obs<-c(odeset[order(odeset$Time), "Protc"], odeset[order(odeset$Time), c("r")])
        Yhat$Substrate<-rep(odeset[order(odeset$Time), "Substrate"], times=2)
        Yhat$Structure<-rep(odeset[order(odeset$Time), "Structure"], times=2)
        
        #rsquared calculation for each variable
        Gfit<-Yhat %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T), 
                                                        SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                        ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        Gfit$R2<-with(Gfit, 1-SSres/SStot)
        Gfit$N<-length(x)
        Gfit$AIC<-with(Gfit, 2*N-2*ll)
        
        rsq_out<-list(Yhat=Yhat, Gfit=Gfit)
        
        return(rsq_out)
        
      }
      
      #approximate parameter estimation is done by MCMC method
      par_mcmc<-modMCMC(f=cost, p=c(Vmax=0.1, Km=3, CUE=0.5, mr=0.01, fp=0.5, Cmic_0=0.01), 
                          lower=c(Vmax=1e-3, Km=1e-3, CUE=0, mr=1e-5, fp=0, Cmic_0=1e-5),
                          upper=c(Vmax=10, Km=100, CUE=1, mr=10, fp=1, Cmic_0=5), niter=10000)
      
      #lower and upper limits for parameters are extracted
      pl<-summary(par_mcmc)["min",]
      pu<-summary(par_mcmc)["max",]
      
      #these limits are used to find global optimum by DEoptim
      opt_par<-DEoptim(fn=cost, lower=pl, upper=pu, 
                       control = c(itermax = 10000, steptol = 50, reltol = 1e-8, 
                                   trace=FALSE, strategy=3, NP=250))
      
      #global optimum parameters are further used in MCMC to find parameters distribution
      par_prof<-modMCMC(f=cost, p=opt_par$optim$bestmem, 
                        lower=pl,
                        upper=pu, niter=5000)
      
      #goodness of fit
      fit<-rsq_ode(opt_par$optim$bestmem)
      
      #best parameters
      p<-opt_par$optim$bestmem
      names(p)<-parnames
      
      #return list with opt_par and par_prof
      estim_out<-list(pars=p, par_prof=par_prof, fit=fit)
      
      return(estim_out)
    
    }
    
    
    #parameter estimation
    if(FACT==4){
      
      res<-vector("list", length = 1)
      res[[1]]<-estim(odeset=dat)
      
    }else{
      
      res<-foreach(i=unique(dat$id), .combine=list, .multicombine = TRUE,
                   .packages=c("FME", "dplyr", "DEoptim", "reshape")) %dopar% {
                     
                     estim(odeset=dat[dat$id==i,])
                     
                   }
    }
    
    
    #calculation of overall goodness of fit from individual results
    if(FACT==4){
      
      res$goodness<-res[[1]]$fit$Gfit
      res$OvP<-res[[1]]$fit$Yhat
      
    }else{
      
      if(FACT==1){
        
        res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat)
        
        #rsquared calculation for each variable
        res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T), 
                                                               SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                               ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
        res$goodness$N<-rep(length(parnames)*2, times=2)
        res$goodness$AIC<-with(res$goodness, 2*N-2*ll)
        
        
      }else{
        
        if(FACT==2){
          
          res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat, res[[3]]$fit$Yhat)
          
          #rsquared calculation for each variable
          res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T), 
                                                                 SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                 ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
          res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
          res$goodness$N<-rep(length(parnames)*3, times=2)
          res$goodness$AIC<-with(res$goodness, 2*N-2*ll)
          
        }else{
          
          res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat, res[[3]]$fit$Yhat, res[[4]]$fit$Yhat, res[[5]]$fit$Yhat, res[[6]]$fit$Yhat)
          
          #rsquared calculation for each variable
          res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T), 
                                                                 SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                 ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
          res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
          res$goodness$N<-rep(length(parnames)*6, times=2)
          res$goodness$AIC<-with(res$goodness, 2*N-2*ll)
          
        }
        
      }
      
    }
    
  return(res)
  
}
##############################################DNA##############################################
mend_i_DNA<-function(data, FACT){
  
  #FACT 1 = Substrate, 2=Structure, 3=Both, 4=No
  
  if(FACT==1){
    
    dat<-data
    dat$id<-ifelse(d$Substrate=="Glucose", 1, 2)
    
  }else{
    
    if(FACT==2){
      
      dat<-data
      dat<-data
      ids<-dat %>% group_by(Structure) %>% summarise(id=n())
      ids$id<-seq(1:nrow(ids))
      
      dat<-merge(dat, ids, by.x=c("Structure"), by.y=c("Structure"))
      
    }else{
      
      if(FACT==3){
        
        dat<-data
        ids<-dat %>% group_by(Substrate, Structure) %>% summarise(id=n())
        ids$id<-seq(1:nrow(ids))
        
        dat<-merge(dat, ids, by.x=c("Substrate","Structure"), by.y=c("Substrate", "Structure"))
        
        
      }else{
        
        dat<-data
        dat$id<-c(1)
        
      }
    }
  }
  
    #mend model
    deriv<-function(time, state, pars){
      
      with(as.list(c(state, pars)),{
        
       #equations
        #C uptake
        Cu=Vmax*Cmic*C/(Km+C)
        #respiration
        r=mr*Cmic+(1-CUE)*Cu
        
        #Protc=Cmic*fp
        DNAc=Cmic*fd
        
        #states
        dCmic<-CUE*Cu-mr*Cmic
        dC<--Cu
        
        return(list(c(dCmic, dC), r=r, DNAc=DNAc))
        
      })
    }
    #define names of parameters
    parnames<-c("Vmax", "Km", "CUE", "mr", "fd", "Cmic_0")
    
    #parameters estimation function
    estim<-function(odeset){
      
      #defining cost function
      cost<-function(x){
        
        par<-x[1:length(parnames)]
        
        names(par)<-parnames
        
        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(Cmic=par[["Cmic_0"]], C=25), parms=par, deriv, times=sort(odeset$Time)))
        
        #select time and the measured variables 
        yhat<-select(yhat_all, c("time", "DNAc", "r"))
        
        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")
        
        #add the measured data to a data frame
        Yhat$obs<-c(odeset[order(odeset$Time), "DNAc"], odeset[order(odeset$Time), c("r")])
        
        #add the weighting factor
        #I want to have the weighting factor to be proportional to mean of the given variable 
        yweights<-Yhat %>% group_by(variable) %>% summarise(weights=mean(value, na.rm = T))
        
        #match with the Yhat data frame
        Yhat<-merge(Yhat, yweights, by.x=c("variable"), by.y=c("variable"))
        
        #now, the root mean square error is calculated
        NRMSE<-as.numeric(Yhat %>% group_by(variable) %>% summarise(NRMSE=sum((((value-obs)/mean(weights))^2), na.rm = T)) %>% 
                            summarise(NRMSE=sum(NRMSE)))
        
        return(NRMSE)
        
      }
      
      #defining goodness of fit function 
      rsq_ode<-function(x){
        
        par<-x[1:length(parnames)]
        
        names(par)<-parnames
        
        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(Cmic=par[["Cmic_0"]], C=25), parms=par, deriv, times=sort(odeset$Time)))
        
        #select time and the measured variables 
        yhat<-select(yhat_all, c("time", "DNAc", "r"))
        
        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")
        
        #add the measured data to a data frame
        Yhat$obs<-c(odeset[order(odeset$Time), "DNAc"], odeset[order(odeset$Time), c("r")])
        Yhat$Substrate<-rep(odeset[order(odeset$Time), "Substrate"], times=2)
        Yhat$Structure<-rep(odeset[order(odeset$Time), "Structure"], times=2)
        
        #rsquared calculation for each variable
        Gfit<-Yhat %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T), 
                                                        SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                        ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        Gfit$R2<-with(Gfit, 1-SSres/SStot)
        Gfit$N<-length(x)
        Gfit$AIC<-with(Gfit, 2*N-2*ll)
        
        rsq_out<-list(Yhat=Yhat, Gfit=Gfit)
        
        return(rsq_out)
        
      }
      
      #approximate parameter estimation is done by MCMC method
      par_mcmc<-modMCMC(f=cost, p=c(Vmax=0.1, Km=3, CUE=0.5, mr=0.01, fd=0.5, Cmic_0=0.01), 
                          lower=c(Vmax=1e-3, Km=1e-3, CUE=0, mr=1e-5, fd=0, Cmic_0=1e-5),
                          upper=c(Vmax=10, Km=100, CUE=1, mr=10, fd=1, Cmic_0=5), niter=10000)
      
      #lower and upper limits for parameters are extracted
      pl<-summary(par_mcmc)["min",]
      pu<-summary(par_mcmc)["max",]
      
      #these limits are used to find global optimum by DEoptim
      opt_par<-DEoptim(fn=cost, lower=pl, upper=pu, 
                       control = c(itermax = 10000, steptol = 50, reltol = 1e-8, 
                                   trace=FALSE, strategy=3, NP=250))
      
      #global optimum parameters are further used in MCMC to find parameters distribution
      par_prof<-modMCMC(f=cost, p=opt_par$optim$bestmem, 
                        lower=pl,
                        upper=pu, niter=5000)
      
      #goodness of fit
      fit<-rsq_ode(opt_par$optim$bestmem)
      
      #best parameters
      p<-opt_par$optim$bestmem
      names(p)<-parnames
      
      #return list with opt_par and par_prof
      estim_out<-list(pars=p, par_prof=par_prof, fit=fit)
      
      return(estim_out)
    
    }
    
    
    #parameter estimation
    if(FACT==4){
      
      res<-vector("list", length = 1)
      res[[1]]<-estim(odeset=dat)
      
    }else{
      
      res<-foreach(i=unique(dat$id), .combine=list, .multicombine = TRUE,
                   .packages=c("FME", "dplyr", "DEoptim", "reshape")) %dopar% {
                     
                     estim(odeset=dat[dat$id==i,])
                     
                   }
    }
    
    
    #calculation of overall goodness of fit from individual results
    if(FACT==4){
      
      res$goodness<-res[[1]]$fit$Gfit
      res$OvP<-res[[1]]$fit$Yhat
      
    }else{
      
      if(FACT==1){
        
        res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat)
        
        #rsquared calculation for each variable
        res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T), 
                                                               SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                               ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
        res$goodness$N<-rep(length(parnames)*2, times=2)
        res$goodness$AIC<-with(res$goodness, 2*N-2*ll)
        
        
      }else{
        
        if(FACT==2){
          
          res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat, res[[3]]$fit$Yhat)
          
          #rsquared calculation for each variable
          res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T), 
                                                                 SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                 ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
          res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
          res$goodness$N<-rep(length(parnames)*3, times=2)
          res$goodness$AIC<-with(res$goodness, 2*N-2*ll)
          
        }else{
          
          res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat, res[[3]]$fit$Yhat, res[[4]]$fit$Yhat, res[[5]]$fit$Yhat, res[[6]]$fit$Yhat)
          
          #rsquared calculation for each variable
          res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T), 
                                                                 SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                 ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
          res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
          res$goodness$N<-rep(length(parnames)*6, times=2)
          res$goodness$AIC<-with(res$goodness, 2*N-2*ll)
          
        }
        
      }
      
    }
    
  return(res)
  
}
```

```{r eval=F, echo=T}
#Proteins
#across all treatments
mend_i1<-mend_i(data=d, FACT = 4)

no_cors<-detectCores()-1
cl<-makeCluster(no_cors)
registerDoParallel(cl)

#for different structures
mend_i2<-mend_i(data=d, FACT = 2)

#for different substrates
mend_i3<-mend_i(data=d, FACT = 1)

#for each separately 
mend_i4<-mend_i(data=d, FACT = 3)

stopImplicitCluster()

mend_i1$goodness
mend_i2$goodness
mend_i3$goodness
mend_i4$goodness

#DNA
#across all treatments
mend_i1_DNA<-mend_i_DNA(data=d, FACT = 4)

no_cors<-detectCores()
cl<-makeCluster(no_cors)
registerDoParallel(cl)

#for different structures
mend_i2_DNA<-mend_i_DNA(data=d, FACT = 2)

#for different substrates
mend_i3_DNA<-mend_i_DNA(data=d, FACT = 1)

#for each separately 
mend_i4_DNA<-mend_i_DNA(data=d, FACT = 3)

stopImplicitCluster()

mend_i1_DNA$goodness
mend_i2_DNA$goodness
mend_i3_DNA$goodness
mend_i4_DNA$goodness

```

```{r MEND overall calibration results, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

# #results of the previous iteration (not run)
# mend_all_results_par<-rbind(mend_i1[[1]]$pars, mend_i1_DNA[[1]]$pars,
#                   mend_i2[[1]]$pars, mend_i2[[2]]$pars, mend_i2[[3]]$pars,
#                   mend_i2_DNA[[1]]$pars, mend_i2_DNA[[2]]$pars, mend_i2_DNA[[3]]$pars,
#                   mend_i3[[1]]$pars, mend_i3[[2]]$pars,
#                   mend_i3_DNA[[1]]$pars, mend_i3_DNA[[2]]$pars,
#                   mend_i4[[1]]$pars, mend_i4[[2]]$pars, mend_i4[[3]]$pars,
#                   mend_i4[[4]]$pars, mend_i4[[5]]$pars, mend_i4[[6]]$pars,
#                   mend_i4_DNA[[1]]$pars, mend_i4_DNA[[2]]$pars, mend_i4_DNA[[3]]$pars,
#                   mend_i4_DNA[[4]]$pars, mend_i4_DNA[[5]]$pars, mend_i4_DNA[[6]]$pars)
# 
# mend_all_results_good<-rbind(mend_i1$goodness[c(2,1),c(4:7)],
#                 mend_i2$goodness[c(2,1),c(4:7)],
#                 mend_i3$goodness[c(2,1),c(4:7)],
#                 mend_i4$goodness[c(2,1),c(4:7)],
#                 mend_i1_DNA$goodness[c(2,1),c(4:7)],
#                 mend_i2_DNA$goodness[c(2,1),c(4:7)],
#                 mend_i3_DNA$goodness[c(2,1),c(4:7)],
#                 mend_i4_DNA$goodness[c(2,1),c(4:7)])
# 
# mend_all_results_good[mend_all_results_good$R2<0,"R2"]<-c(0)
# mend_all_results_good$Name<-c(rep(c("Respiration rate", "Protein"), times=4),
#                              rep(c("Respiration rate", "DNA"), times=4))
# mend_all_results_good<-mend_all_results_good[,c(5,1,2,3,4)]
# 
# 
# write.csv(mend_all_results_par, file = c("../mend_all_results_par.csv"), row.names = F)
# write.csv(mend_all_results_good, file = c("../mend_all_results_good.csv"), row.names = F)

mend_all_results_par<-read.csv("mend_all_results_par.csv")
mend_all_results_good<-read.csv("mend_all_results_good.csv")


t.s5.1<-data.frame(Name=rep(c("All", "Broth", "Glass", "Wool",
                    "Cellobiose", "Glucose",
                    "Broth - Cellobiose", "Broth - Glucose",
                    "Glass - Cellobiose", "Glass - Glucose",
                    "Wool - Cellobiose", "Wool - Glucose"), each =2),
                   Parameter=rep(c("Protein", "DNA"), times=12),
                   Vmax=mend_all_results_par[,1],
                   Km=mend_all_results_par[,2],
                   CUE=mend_all_results_par[,3],
                   mr=mend_all_results_par[,4],
                   conv=mend_all_results_par[,5])

options(knitr.kable.NA = '')


kable(t.s5.1, digits = c(0, 0, 2, 2, 2, 3, 2), align = 'c', "html", booktabs=T, col.names = c(" "," ", '$\\V_{MAX}$', '$\\K_{M}$', 'CUE', '$\\m_{R}$', 'Conversion factor'), row.names=F, caption = "_**Table S11:** MEND model parameters calibrated against respiration rate and protein/DNA concentration across all treatments (All), for different levels of incubation system complexity separately (Structure), for Glucose and Celluloze treatments separately (Substrate), and for all experimental treatments separatelly (Each). See Materials and Methods for symbols explanation._") %>% 
  kable_styling() %>% 
  group_rows("All", 1, 2) %>%
  group_rows("Structure", 3, 8) %>%
  group_rows("Substrate", 9, 12) %>%
  group_rows("Each", 13, 24) 

kable(mend_all_results_good, digits = c(0, 2, 2, 2, 2), align = 'c', "html", booktabs=T, col.names = c(" " , 'Log Likelihood', '$\\R^{2}$', 'Number of parameters', 'AIC'), row.names=F, caption = "_**Table S12:** Goodness of fit of MEND model calibrated against respiration rate and protein/DNA concentration across all treatments (All), for different levels of incubation system complexity separately (Structure), for Glucose and Celluloze treatments separately (Substrate), and for all experimental treatments separatelly (Each). See Materials and Methods for symbols explanation._") %>% 
  kable_styling() %>% 
  group_rows("Protein", 1, 8, label_row_css = "background-color: #666; color: #fff;") %>%
  group_rows("All", 1, 2) %>%
  group_rows("Structure", 3, 4) %>%
  group_rows("Substrate", 5, 6) %>%
  group_rows("Each", 7, 8) %>%
  group_rows("DNA", 9, 16, label_row_css = "background-color: #666; color: #fff;") %>%
  group_rows("All", 9, 10) %>%
  group_rows("Structure",11, 12) %>%
  group_rows("Substrate", 13, 14) %>%
  group_rows("Each", 15, 16) 

```

####DEB model
```{r DEB model, eval=F, echo=T}
deb_i_all<-function(data, FACT){

  #FACT 1 = Substrate, 2=Structure, 3=Both, 4=No


  #if factor needs to be included, its levels are defined
  if(FACT==1){

    dat<-data
    dat$id<-ifelse(data$Substrate=="Glucose", 1, 2)

  }else{

    if(FACT==2){

      dat<-data
      dat<-data
      ids<-dat %>% group_by(Structure) %>% summarise(id=n())
      ids$id<-seq(1:nrow(ids))

      dat<-merge(dat, ids, by.x=c("Structure"), by.y=c("Structure"))

    }else{

      if(FACT==3){

        dat<-data
        ids<-dat %>% group_by(Substrate, Structure) %>% summarise(id=n())
        ids$id<-seq(1:nrow(ids))

        dat<-merge(dat, ids, by.x=c("Substrate","Structure"), by.y=c("Substrate", "Structure"))


      }else{

        dat<-data
        dat$id<-c(1)

      }
    }
  }

    #deb model
    deriv<-function(time, state, pars){

      with(as.list(c(state, pars)),{

        #Carbon uptake
        Cu=Vmax*C*S/(Km+C)

        #maintnance
        m=S*m0

        #reserve mobilization rate for growth and enzyme production
        an=f*R-m

        #calibrated variables
        #protein abundance in reserves and structures is mean value reported
        #by Hanegraaf and Muller, 2001
        r=m+pmax(an*(1-Yu), 0)

        #Protc=0.7095*S+0.6085*R
        Protc=fpr*R+fps*S
        DNAc=fds*S

        dR<-Cu-f*R
        dS<-pmax(an*Yu,0)+pmin(0, an)
        dC<--Cu


        return(list(c(dR, dS, dC), r=r, Protc=Protc, DNAc=DNAc))

      })
    }
    #define names of parameters
    parnames<-c("Vmax", "Km", "m0", "f", "Yu", "fpr", "fps", "fds", "R_0", "S_0")

    #parameters estimation function
    estim<-function(odeset){

      #defining cost function
      cost<-function(x){

        par<-x[1:length(parnames)]

        names(par)<-parnames

        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(R=par[["R_0"]], S=par[["S_0"]], C=25), parms=par, deriv, times=sort(odeset$Time)))

        #select time and the measured variables
        yhat<-select(yhat_all, c("time", "r", "Protc", "DNAc"))

        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")

        #add the measured data to a data frame
        Yhat$obs<-c(odeset[order(odeset$Time), c("r")], odeset[order(odeset$Time), "Protc"], odeset[order(odeset$Time), "DNAc"])

        #add the weighting factor
        #I want to have the weighting factor to be proportional to mean of the given variable
        yweights<-Yhat %>% group_by(variable) %>% summarise(weights=mean(value, na.rm = T))

        #match with the Yhat data frame
        Yhat<-merge(Yhat, yweights, by.x=c("variable"), by.y=c("variable"))

        #now, the root mean square error is calculated
        NRMSE<-as.numeric(Yhat %>% group_by(variable) %>% summarise(NRMSE=sum((((value-obs)/mean(weights))^2), na.rm = T)) %>%
                            summarise(NRMSE=sum(NRMSE)))

        return(NRMSE)

      }

      #defining goodness of fit function
      rsq_ode<-function(x){

        par<-x[1:length(parnames)]

        names(par)<-parnames

        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(R=par[["R_0"]], S=par[["S_0"]], C=25), parms=par, deriv, times=sort(odeset$Time)))

        #select time and the measured variables
        yhat<-select(yhat_all, c("time", "r", "Protc", "DNAc"))

        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")

        #add the measured data to a data frame
        Yhat$obs<-c(odeset[order(odeset$Time), c("r")], odeset[order(odeset$Time), "Protc"], odeset[order(odeset$Time), "DNAc"])
        Yhat$Substrate<-rep(odeset[order(odeset$Time), "Substrate"], times=3)
        Yhat$Structure<-rep(odeset[order(odeset$Time), "Structure"], times=3)

        #rsquared calculation for each variable
        Gfit<-Yhat %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T),
                                                        SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                        ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        Gfit$R2<-with(Gfit, 1-SSres/SStot)
        Gfit$N<-c(10)
        Gfit$AIC<-with(Gfit, 2*N-2*ll)

        rsq_out<-list(Yhat=Yhat, Gfit=Gfit)

        return(rsq_out)

      }

      #approximate parameter estimation is done by MCMC method
      par_mcmc<-modMCMC(f=cost, p=c(Vmax=0.1, Km=3, m0=0.01, f=4, Yu=0.8, fpr=0.5, fps=0.5, fds=0.03, R_0=0.03483481, S_0=0.07661063),
                          lower=c(Vmax=1e-5, Km=1e-2, m0=1e-5, f=1e-3, Yu=0.01, fpr=0, fps=0, fds=0, R_0=1e-4, S_0=1e-4),
                          upper=c(Vmax=1, Km=20, m0=1, f=100, Yu=0.8, fpr=1, fps=1, fds=1, R_0=2, S_0=2), niter=10000)

      #lower and upper limits for parameters are extracted
      pl<-summary(par_mcmc)["min",]
      pu<-summary(par_mcmc)["max",]

      #these limits are used to find global optimum by DEoptim
      opt_par<-DEoptim(fn=cost, lower=pl, upper=pu,
                       control = c(itermax = 10000, steptol = 50, reltol = 1e-8,
                                   trace=FALSE, strategy=3, NP=250))

      #global optimum parameters are further used in MCMC to find parameters distribution
      par_prof<-modMCMC(f=cost, p=opt_par$optim$bestmem,
                        lower=pl,
                        upper=pu, niter=5000)

      #goodness of fit
      fit<-rsq_ode(opt_par$optim$bestmem)

      #best parameters
      p<-opt_par$optim$bestmem
      names(p)<-parnames

      #return list with opt_par and par_prof
      estim_out<-list(pars=p, par_prof=par_prof, fit=fit)

      return(estim_out)

    }


    #parameter estimation
    if(FACT==4){

      res<-vector("list", length = 1)
      res[[1]]<-estim(odeset=dat)

    }else{

      res<-foreach(i=unique(dat$id), .combine=list, .multicombine = TRUE,
                   .packages=c("FME", "dplyr", "DEoptim", "reshape")) %dopar% {

                     estim(odeset=dat[dat$id==i,])

                   }
    }


    #calculation of overall goodness of fit from individual results
    if(FACT==4){

      res$goodness<-res[[1]]$fit$Gfit
      res$OvP<-res[[1]]$fit$Yhat

    }else{

      if(FACT==1){

        res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat)

        #rsquared calculation for each variable
        res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T),
                                                               SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                               ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
        res$goodness$N<-rep(length(parnames)*2, times=3)
        res$goodness$AIC<-with(res$goodness, 2*N-2*ll)


      }else{

        if(FACT==2){

          res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat, res[[3]]$fit$Yhat)

          #rsquared calculation for each variable
          res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T),
                                                                 SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                 ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
          res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
          res$goodness$N<-rep(length(parnames)*3, times=3)
          res$goodness$AIC<-with(res$goodness, 2*N-2*ll)

        }else{

          res$OvP<-rbind(res[[1]]$fit$Yhat, res[[2]]$fit$Yhat, res[[3]]$fit$Yhat, res[[4]]$fit$Yhat, res[[5]]$fit$Yhat, res[[6]]$fit$Yhat)

          #rsquared calculation for each variable
          res$goodness<-res$OvP %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T),
                                                                 SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                                 ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
          res$goodness$R2<-with(res$goodness, 1-SSres/SStot)
          res$goodness$N<-rep(length(parnames)*6, times=3)
          res$goodness$AIC<-with(res$goodness, 2*N-2*ll)

        }

      }

    }

  return(res)

}
```

```{r, eval=F, echo=T}

#across all treatments
deb_i1_all<-deb_i_all(data=d, FACT = 4)

no_cors<-detectCores()-1
cl<-makeCluster(no_cors)
registerDoParallel(cl)

#for different structures
deb_i2_all<-deb_i_all(data=d, FACT = 2)

#the initial R and S concentrations are estimated for each treatment separately
#the following code is run with the fixed initial R and S concentrations
#across treatments (observed mean)
#this is done only with instances in which the model simulation can explain more than 0% 
#of the variability in protein and/or DNA dynamic  
deb_i2_all_fix<-deb_i_all_fix(data=d, FACT = 2)

#in the following code, the Ys parameter is fixed across treatments
#becuase its variability across treatments is minimal (data not shown)
deb_i2_all_fix_Yu<-deb_i_all_fix_Yu(data=d, FACT = 2)

#for different substrates
deb_i3_all<-deb_i_all(data=d, FACT = 1)

#for each separately 
deb_i4_all<-deb_i_all(data=d, FACT = 3)

deb_i4_all_fix<-deb_i_all_fix(data=d, FACT = 3)

stopImplicitCluster()

deb_i1_all$goodness
deb_i2_all$goodness
deb_i3_all$goodness
deb_i4_all$goodness


```

```{r DEB overall calibration results, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

#results of the previous iteration (not run)
# deb_all_results_par<-rbind(deb_i1_all[[1]]$pars[1:8], 
#                    c(deb_i2_all_fix_Yu[[1]]$pars[1:4], Yu=0.6, deb_i2_all_fix_Yu[[1]]$pars[5:7]), c(deb_i2_all_fix_Yu[[2]]$pars[1:4], Yu=0.6, deb_i2_all_fix_Yu[[2]]$pars[5:7]), c(deb_i2_all_fix_Yu[[3]]$pars[1:4], Yu=0.6, deb_i2_all_fix_Yu[[3]]$pars[5:7]),
#                    deb_i3_all[[1]]$pars[1:8], deb_i3_all[[2]]$pars[1:8],
#                    deb_i4_all[[1]]$pars[1:8], deb_i4_all[[2]]$pars[1:8], deb_i4_all[[3]]$pars[1:8],
#                    deb_i4_all[[4]]$pars[1:8], deb_i4_all[[5]]$pars[1:8], deb_i4_all[[6]]$pars[1:8])
# 
# deb_all_results_good<-rbind(deb_i1_all$goodness[,c(4:7)],
#                  deb_i2_all_fix_Yu$goodness[,c(4:7)],
#                  deb_i3_all$goodness[,c(4:7)],
#                  deb_i4_all$goodness[,c(4:7)])
# 
# deb_all_results_good[deb_all_results_good$R2<0,"R2"]<-c(0)
# deb_all_results_good$Name<-rep(c("Respiration rate", "Protein", "DNA"), times=4)
# deb_all_results_good<-deb_all_results_good[,c(5,1,2,3,4)]
#  
# 
# write.csv(deb_all_results_par, file = c("../deb_all_results_par.csv"), row.names = F)
# write.csv(deb_all_results_good, file = c("../deb_all_results_good.csv"), row.names = F)

deb_all_results_par<-read.csv("deb_all_results_par.csv")
deb_all_results_good<-read.csv("deb_all_results_good.csv")


t.s6.1<-data.frame(Name=c("All", "Broth", "Glass", "Wool",
                    "Cellobiose", "Glucose",
                    "Broth - Cellobiose", "Broth - Glucose",
                    "Glass - Cellobiose", "Glass - Glucose",
                    "Wool - Cellobiose", "Wool - Glucose"),
                   Vmax=deb_all_results_par[,1],
                   Km=deb_all_results_par[,2],
                   m0=deb_all_results_par[,3],
                   f=deb_all_results_par[,4],
                   Yu=deb_all_results_par[,5],
                   fpr=deb_all_results_par[,6],
                   fps=deb_all_results_par[,7],
                   fds=deb_all_results_par[,8])

options(knitr.kable.NA = '')


kable(t.s6.1, digits = c(0, 2, 2, 3, 2, 2, 2, 2, 2), align = 'c', "html", booktabs=T, col.names = c(" ",'$\\V_{MAX}$', '$\\K_{M}$', '$\\m_{R}$', '$\\f_{0}$', '$\\Y_{S}$', '$\\R_{Proteins}$', '$\\S_{Proteins}$', '$\\S_{DNA}$'), row.names=F, caption = "_**Table S13:** DEB model parameters calibrated against respiration rate, protein and DNA concentration across all treatments (All), for different levels of incubation system complexity separately (Structure), for Glucose and Celluloze treatments separately (Substrate), and for all experimental treatments separatelly (Each). See Materials and Methods for symbols explanation._") %>% 
  kable_styling() %>% 
  group_rows("All", 1, 1) %>%
  group_rows("Structure", 2, 4) %>%
  group_rows("Substrate", 5, 6) %>%
  group_rows("Each", 7, 12) 

kable(deb_all_results_good, digits = c(0, 2, 2, 2, 2), align = 'c', "html", booktabs=T, col.names = c(" " , 'Log Likelihood', '$\\R^{2}$', 'Number of parameters', 'AIC'), row.names=F, caption = "_**Table S14:** Goodness of fit of DEB model calibrated against respiration rate, protein and DNA concentration across all treatments (All), for different levels of incubation system complexity separately (Structure), for Glucose and Celluloze treatments separately (Substrate), and for all experimental treatments separatelly (Each). See Materials and Methods for symbols explanation._") %>% 
  kable_styling() %>% 
  group_rows("All", 1, 3) %>%
  group_rows("Structure", 4, 6) %>%
  group_rows("Substrate", 7, 9) %>%
  group_rows("Each", 10, 12) 
  

```

$~$
$~$
$~$
$~$
$~$
$~$
```{r correlation figure, echo=FALSE, fig.height=5, fig.width=10, fig.cap="Fig. S3: Effect of structure of bacterial and fungal part of microbial community (expressed as multivariate mean distance between groups; see Matrial and Methods section) on overall microbial community maintnance respiration rate ($m_{R}$ - (a)) and protein concentration in Reserves pool ($R_{Protein}$ - (b)). The value of both parameters are expressed as a mean difference between groups in order to allow unbiased correlation with microbial community structure metric (see Matrial and Methods section)."}

dpars<-t.s6.1[c(7:12), -1]
dpars$Substrate<-rep(c("Cellobiose", "Glucose"), 3)
dpars$Structure<-c("BROTH", "BROTH", "GLASS", "GLASS", "WOOL", "WOOL")

dpars2<-merge(dpars, bacdiff, by.y=c("Substrate", "Structure"), by.x=c("Substrate", "Structure"))

dpars3<-merge(dpars, fdiff, by.y=c("Substrate", "Structure"), by.x=c("Substrate", "Structure"))

for(i in 3:10){
  dpars2[, i]<-sqrt((dpars2[, i]-as.numeric(dpars2[1, i]))^2)
}

for(i in 3:10){
  dpars3[, i]<-sqrt((dpars3[, i]-as.numeric(dpars3[1, i]))^2)
}

dpars2$group<-c("Bacteria")
dpars3$group<-c("Fungi")
dpars4<-rbind(dpars2, dpars3)

corplot1.p<-coefficients(nls(m0~Dist^x, dpars4, start = list(x=2)))

corplot1<-ggplot(dpars4[dpars4$group=="Bacteria", ], aes(Dist, m0*1e4))+
  geom_point(cex=6, aes(fill=Structure), show.legend=T, shape=21)+
  geom_point(data=dpars4[dpars4$group=="Fungi", ], cex=6, 
             aes(x=Dist, y=m0*1e4, fill=Structure), show.legend=F, shape=22)+
  scale_fill_manual(values = c("black", "grey", "white"))+
  stat_function(fun = function(x){(x^corplot1.p)*1e4}, lwd=1, colour="grey30")+
  xlab("16S and ITS Distance")+
  ggtitle("a)")+
  ylab(expression(paste(m[R]~difference)))+
  theme_min+theme(legend.title = element_blank(),
                  legend.position = c(0.2,0.8))

corplot2.p<-coefficients(nls(fpr~Dist^x, dpars4, start = list(x=2)))

corplot2<-ggplot(dpars4[dpars4$group=="Bacteria", ], aes(Dist, fpr))+
  geom_point(cex=6, aes(fill=Structure), show.legend=F, shape=21)+
  geom_point(data=dpars4[dpars4$group=="Fungi", ], cex=6, 
             aes(x=Dist, y=fpr, fill=Structure), show.legend=F, shape=22)+
  scale_fill_manual(values = c("black", "grey", "white"))+
  stat_function(fun = function(x){(x^corplot2.p)}, lwd=1, colour="grey30")+
  xlab("16S and ITS Distance")+
  ggtitle("b)")+
  ylab(expression(paste(R[Proteins]~difference)))+
  theme_min

grid.arrange(corplot1, corplot2, nrow=1)


```


```{r picina example, eval=FALSE, include=TRUE}

#######################################Monod model##################################################
monod_ex<-function(data){

   #monod growth function
    deriv<-function(time, state, pars){
      
      with(as.list(c(state, pars)),{
        
        Cb<-matrix(state[1:5], ncol = 1)
        C<-matrix(state[6:10], ncol = 1)
        
        dCb<--k*Cb+CUE*Vmax*Cb*C/(Km+C)
        dC<-k*Cb-Vmax*Cb*C/(Km+C)
        
        return(list(c(dCb, dC), r=(1-CUE)*Vmax*Cb*C/(Km+C), Cmic=kec*Cb))
        
      })
    }
    
    #define names of parameters
    parnames<-c("Vmax", "Km", "CUE", "k", "kec")

    #parameters estimation function
    estim<-function(odeset){

      #defining cost function
      cost<-function(x){

        par<-x[1:length(parnames)]

        names(par)<-parnames
        
        #initial conditions
        Cmicinit=93.6/par[["kec"]]
        Cinit=315

        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(Cb1=Cmicinit, Cb2=Cmicinit, Cb3=Cmicinit, Cb4=Cmicinit, Cb5=Cmicinit,
                                        C1=315, C2=315, C3=315, C4=315, C5=315), parms=par, deriv, times=c(0, 8, 16, 24, 48, 72)))

        #select time and the measured variables
        yhat<-select(yhat_all, c("time", "Cmic1", "Cmic2", "Cmic3","Cmic4", "Cmic5",
                               "C1", "C2", "C3", "C4", "C5",
                               "r1", "r2", "r3", "r4", "r5"))

        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")

        #add the measured data to a data frame
        Yhat$obs<-c(as.numeric(odeset[c(1,6,11,16, 21, 26), c("Cmic")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("Cmic")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("Cmic")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("Cmic")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("Cmic")]),
                  as.numeric(odeset[c(1,6,11,16, 21, 26), c("DOC")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("DOC")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("DOC")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("DOC")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("DOC")]),
                  as.numeric(odeset[c(1,6,11,16, 21, 26), c("r")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("r")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("r")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("r")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("r")]))

        #add the weighting factor
        #I want to have the weighting factor to be proportional to mean of the given variable
        yweights<-Yhat %>% group_by(variable) %>% summarise(weights=mean(value, na.rm = T))

        #match with the Yhat data frame
        Yhat<-merge(Yhat, yweights, by.x=c("variable"), by.y=c("variable"))

        #now, the root mean square error is calculated
        NRMSE<-as.numeric(Yhat %>% group_by(variable) %>% summarise(NRMSE=sum((((value-obs)/mean(weights))^2), na.rm = T)) %>%
                            summarise(NRMSE=sum(NRMSE)))

        return(NRMSE)

      }

      #defining goodness of fit function
      rsq_ode<-function(x){

        par<-x[1:length(parnames)]

        names(par)<-parnames

        #initial conditions
        Cmicinit=93.6/par[["kec"]]
        Cinit=315

        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(Cb1=Cmicinit, Cb2=Cmicinit, Cb3=Cmicinit, Cb4=Cmicinit, Cb5=Cmicinit,
                                        C1=315, C2=315, C3=315, C4=315, C5=315), parms=par, deriv, times=c(0, 8, 16, 24, 48, 72)))

        #select time and the measured variables
        yhat<-select(yhat_all, c("time", "Cmic1", "Cmic2", "Cmic3","Cmic4", "Cmic5",
                               "C1", "C2", "C3", "C4", "C5",
                               "r1", "r2", "r3", "r4", "r5"))

        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")

        #add the measured data to a data frame
        Yhat$obs<-c(as.numeric(odeset[c(1,6,11,16, 21, 26), c("Cmic")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("Cmic")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("Cmic")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("Cmic")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("Cmic")]),
                  as.numeric(odeset[c(1,6,11,16, 21, 26), c("DOC")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("DOC")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("DOC")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("DOC")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("DOC")]),
                  as.numeric(odeset[c(1,6,11,16, 21, 26), c("r")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("r")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("r")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("r")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("r")]))
        
        Yhat$variable<-c(rep("Cmic", 30), rep("C", 30), rep("r", 30))

        #rsquared calculation for each variable
        Gfit<-Yhat %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T),
                                                        SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                        ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        Gfit$R2<-with(Gfit, 1-SSres/SStot)
        Gfit$N<-length(x)
        Gfit$AIC<-with(Gfit, 2*N-2*ll)

        rsq_out<-list(Yhat=Yhat, Gfit=Gfit)

        return(rsq_out)

      }

      #approximate parameter estimation is done by MCMC method
      par_mcmc<-modMCMC(f=cost, p=c(Vmax=0.1, Km=3, CUE=0.5, k=0.01, kec=0.38),
                          lower=c(Vmax=1e-5, Km=1e-2, CUE=0, k=1e-5, kec=0),
                          upper=c(Vmax=1, Km=20, CUE=1, k=10, kec=1), niter=10000)

      #lower and upper limits for parameters are extracted
      pl<-summary(par_mcmc)["min",]
      pu<-summary(par_mcmc)["max",]

      #these limits are used to find global optimum by DEoptim
      opt_par<-DEoptim(fn=cost, lower=pl, upper=pu,
                       control = c(itermax = 10000, steptol = 50, reltol = 1e-8,
                                   trace=FALSE, strategy=3, NP=250))

      #global optimum parameters are further used in MCMC to find parameters distribution
      par_prof<-modMCMC(f=cost, p=opt_par$optim$bestmem,
                        lower=pl,
                        upper=pu, niter=5000)

      #goodness of fit
      fit<-rsq_ode(opt_par$optim$bestmem)

      #best parameters
      p<-opt_par$optim$bestmem
      names(p)<-parnames

      #return list with opt_par and par_prof
      estim_out<-list(pars=p, par_prof=par_prof, fit=fit)

      return(estim_out)

    }
    
    res<-estim(odeset=data)


  return(res)

}

#################################################MEND#######################################################
mend_ex<-function(data){

   #mend growth function
    deriv<-function(time, state, pars){
      
      with(as.list(c(state, pars)),{
        
        Cb<-matrix(state[1:5], ncol = 1)
        C<-matrix(state[6:10], ncol = 1)
        
        dCb<-CUE*Vmax*Cb*C/(Km+C)-mr*Cb
        dC<--Vmax*Cb*C/(Km+C)
        
        return(list(c(dCb, dC), r=(1-CUE)*Vmax*Cb*C/(Km+C)+mr*Cb, Cmic=kec*Cb))
        
      })
    }
    
    #define names of parameters
    parnames<-c("Vmax", "Km", "CUE", "mr", "kec")

    #parameters estimation function
    estim<-function(odeset){

      #defining cost function
      cost<-function(x){

        par<-x[1:length(parnames)]

        names(par)<-parnames
        
        #initial conditions
        Cmicinit=93.6/par[["kec"]]
        Cinit=315

        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(Cb1=Cmicinit, Cb2=Cmicinit, Cb3=Cmicinit, Cb4=Cmicinit, Cb5=Cmicinit,
                                        C1=315, C2=315, C3=315, C4=315, C5=315), parms=par, deriv, times=c(0, 8, 16, 24, 48, 72)))

        #select time and the measured variables
        yhat<-select(yhat_all, c("time", "Cmic1", "Cmic2", "Cmic3","Cmic4", "Cmic5",
                               "C1", "C2", "C3", "C4", "C5",
                               "r1", "r2", "r3", "r4", "r5"))

        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")

        #add the measured data to a data frame
        Yhat$obs<-c(as.numeric(odeset[c(1,6,11,16, 21, 26), c("Cmic")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("Cmic")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("Cmic")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("Cmic")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("Cmic")]),
                  as.numeric(odeset[c(1,6,11,16, 21, 26), c("DOC")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("DOC")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("DOC")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("DOC")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("DOC")]),
                  as.numeric(odeset[c(1,6,11,16, 21, 26), c("r")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("r")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("r")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("r")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("r")]))

        #add the weighting factor
        #I want to have the weighting factor to be proportional to mean of the given variable
        yweights<-Yhat %>% group_by(variable) %>% summarise(weights=mean(value, na.rm = T))

        #match with the Yhat data frame
        Yhat<-merge(Yhat, yweights, by.x=c("variable"), by.y=c("variable"))

        #now, the root mean square error is calculated
        NRMSE<-as.numeric(Yhat %>% group_by(variable) %>% summarise(NRMSE=sum((((value-obs)/mean(weights))^2), na.rm = T)) %>%
                            summarise(NRMSE=sum(NRMSE)))

        return(NRMSE)

      }

      #defining goodness of fit function
      rsq_ode<-function(x){

        par<-x[1:length(parnames)]

        names(par)<-parnames

        #initial conditions
        Cmicinit=93.6/par[["kec"]]
        Cinit=315

        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(Cb1=Cmicinit, Cb2=Cmicinit, Cb3=Cmicinit, Cb4=Cmicinit, Cb5=Cmicinit,
                                        C1=315, C2=315, C3=315, C4=315, C5=315), parms=par, deriv, times=c(0, 8, 16, 24, 48, 72)))

        #select time and the measured variables
        yhat<-select(yhat_all, c("time", "Cmic1", "Cmic2", "Cmic3","Cmic4", "Cmic5",
                               "C1", "C2", "C3", "C4", "C5",
                               "r1", "r2", "r3", "r4", "r5"))

        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")

        #add the measured data to a data frame
        Yhat$obs<-c(as.numeric(odeset[c(1,6,11,16, 21, 26), c("Cmic")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("Cmic")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("Cmic")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("Cmic")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("Cmic")]),
                  as.numeric(odeset[c(1,6,11,16, 21, 26), c("DOC")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("DOC")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("DOC")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("DOC")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("DOC")]),
                  as.numeric(odeset[c(1,6,11,16, 21, 26), c("r")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("r")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("r")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("r")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("r")]))
        
        Yhat$variable<-c(rep("Cmic", 30), rep("C", 30), rep("r", 30))

        #rsquared calculation for each variable
        Gfit<-Yhat %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T),
                                                        SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                        ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        Gfit$R2<-with(Gfit, 1-SSres/SStot)
        Gfit$N<-length(x)
        Gfit$AIC<-with(Gfit, 2*N-2*ll)

        rsq_out<-list(Yhat=Yhat, Gfit=Gfit)

        return(rsq_out)

      }

      #approximate parameter estimation is done by MCMC method
      par_mcmc<-modMCMC(f=cost, p=c(Vmax=0.1, Km=3, CUE=0.5, mr=0.01,kec=0.38),
                          lower=c(Vmax=1e-5, Km=1e-2, CUE=0, mr=1e-5, kec=0),
                          upper=c(Vmax=1, Km=20, CUE=1, mr=10, kec=1), niter=10000)

      #lower and upper limits for parameters are extracted
      pl<-summary(par_mcmc)["min",]
      pu<-summary(par_mcmc)["max",]

      #these limits are used to find global optimum by DEoptim
      opt_par<-DEoptim(fn=cost, lower=pl, upper=pu,
                       control = c(itermax = 10000, steptol = 50, reltol = 1e-8,
                                   trace=FALSE, strategy=3, NP=250))

      #global optimum parameters are further used in MCMC to find parameters distribution
      par_prof<-modMCMC(f=cost, p=opt_par$optim$bestmem,
                        lower=pl,
                        upper=pu, niter=5000)

      #goodness of fit
      fit<-rsq_ode(opt_par$optim$bestmem)

      #best parameters
      p<-opt_par$optim$bestmem
      names(p)<-parnames

      #return list with opt_par and par_prof
      estim_out<-list(pars=p, par_prof=par_prof, fit=fit)

      return(estim_out)

    }
    
    res<-estim(odeset=data)


  return(res)

}

#################################################DEB#######################################################
deb_ex<-function(data){

   #deb function
    deriv<-function(time, state, pars){
      
      with(as.list(c(state, pars)),{
        
      R<-matrix(state[1:5], ncol = 1)
      S<-matrix(state[6:10], ncol = 1)
      C<-matrix(state[11:15], ncol = 1)
      
      #C uptake
      Cu=Vmax*S*C/(Km+C)
      
      #udrzovani
      m=S*m0
      
      #mobilizace rezerv
      an=f*R-m
      
      #respirace
      r=m+pmax(an*(1-Yu), 0)
      
      #microbialni uhlik je neco z rezerv a neco ze struktur
      Cmic=fr*R+fs*S
      
      dR<-Cu-f*R
      dS<-pmax(an*Yu,0)+pmin(0, an)
      dC<--Cu
      
      
      return(list(c(dR, dS, dC), Cmic=Cmic, r=r))
        
      })
    }
    
    #define names of parameters
    parnames<-c("Vmax", "Km", "m0", "f", "Yu", "fr", "fs", "Rinit")

    #parameters estimation function
    estim<-function(odeset){

      #defining cost function
      cost<-function(x){

        par<-x

        names(par)<-parnames
        
        Cmicinit=93.6
        Cinit=315
      
        #initial R
        Rinit<-par[["Rinit"]]
      
        #initial S is then
        Sinit<-(Cmicinit-Rinit*par[["fr"]])/par[["fs"]]
     
      
        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(R1=Rinit, R2=Rinit, R3=Rinit, R4=Rinit, R5=Rinit,
                                      S1=Sinit, S2=Sinit, S3=Sinit, S4=Sinit, S5=Sinit,
                                      C1=315, C2=315, C3=315, C4=315, C5=315), 
                                  parms=par[1:7], 
                                  deriv, 
                                  times=c(0, 8, 16, 24, 48, 72)))
         #select time and the measured variables 
         yhat<-select(yhat_all, c("time", "Cmic1", "Cmic2", "Cmic3","Cmic4", "Cmic5",
                               "C1", "C2", "C3", "C4", "C5",
                               "r1", "r2", "r3", "r4", "r5"))
      
        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")
      
        
        #add the measured data to a data frame
        Yhat$obs<-c(as.numeric(odeset[c(1,6,11,16, 21, 26), c("Cmic")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("Cmic")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("Cmic")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("Cmic")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("Cmic")]),
                  as.numeric(odeset[c(1,6,11,16, 21, 26), c("DOC")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("DOC")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("DOC")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("DOC")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("DOC")]),
                  as.numeric(odeset[c(1,6,11,16, 21, 26), c("r")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("r")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("r")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("r")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("r")]))

        #add the weighting factor
        #I want to have the weighting factor to be proportional to mean of the given variable
        yweights<-Yhat %>% group_by(variable) %>% summarise(weights=mean(value, na.rm = T))

        #match with the Yhat data frame
        Yhat<-merge(Yhat, yweights, by.x=c("variable"), by.y=c("variable"))

        #now, the root mean square error is calculated
        NRMSE<-as.numeric(Yhat %>% group_by(variable) %>% summarise(NRMSE=sum((((value-obs)/mean(weights))^2), na.rm = T)) %>%
                            summarise(NRMSE=sum(NRMSE))) 

        return(NRMSE)

      }

      #defining goodness of fit function
      rsq_ode<-function(x){

        par<-x

        names(par)<-parnames

        #initial conditions
        Cmicinit=93.6
        Cinit=315
      
        #initial R
        Rinit<-par[["Rinit"]]
      
        #initial S is then
        Sinit<-(Cmicinit-Rinit*par[["fr"]])/par[["fs"]]
     
      
        #first, pars dependent output from ode is matched with measured values
        yhat_all<-as.data.frame(ode(y=c(R1=Rinit, R2=Rinit, R3=Rinit, R4=Rinit, R5=Rinit,
                                      S1=Sinit, S2=Sinit, S3=Sinit, S4=Sinit, S5=Sinit,
                                      C1=315, C2=315, C3=315, C4=315, C5=315), 
                                  parms=par[1:7], 
                                  deriv, 
                                  times=c(0, 8, 16, 24, 48, 72)))
         #select time and the measured variables 
         yhat<-select(yhat_all, c("time", "Cmic1", "Cmic2", "Cmic3","Cmic4", "Cmic5",
                               "C1", "C2", "C3", "C4", "C5",
                               "r1", "r2", "r3", "r4", "r5"))
      
        #reformat to long format data frame
        Yhat<-melt(yhat, id.vars = "time")
      
        
        #add the measured data to a data frame
        Yhat$obs<-c(as.numeric(odeset[c(1,6,11,16, 21, 26), c("Cmic")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("Cmic")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("Cmic")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("Cmic")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("Cmic")]),
                  as.numeric(odeset[c(1,6,11,16, 21, 26), c("DOC")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("DOC")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("DOC")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("DOC")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("DOC")]),
                  as.numeric(odeset[c(1,6,11,16, 21, 26), c("r")]),
                  as.numeric(odeset[c(2,7,12,17, 22, 27), c("r")]),
                  as.numeric(odeset[c(3,8,13,18, 23, 28), c("r")]),
                  as.numeric(odeset[c(4,9,14,19, 24, 29), c("r")]),
                  as.numeric(odeset[c(5,10,15,20, 25, 30), c("r")]))
        
        Yhat$variable<-c(rep("Cmic", 30), rep("C", 30), rep("r", 30))

        #rsquared calculation for each variable
        Gfit<-Yhat %>% group_by(variable) %>% summarise(SSres=sum(((obs-value)^2), na.rm = T),
                                                        SStot=sum(((obs-mean(obs, na.rm = T))^2), na.rm = T),
                                                        ll=-sum(((obs-value)^2), na.rm = T)/2/(sd(obs, na.rm = T)^2))
        Gfit$R2<-with(Gfit, 1-SSres/SStot)
        Gfit$N<-length(x)
        Gfit$AIC<-with(Gfit, 2*N-2*ll)

        rsq_out<-list(Yhat=Yhat, Gfit=Gfit)

        return(rsq_out)

      }

      #approximate parameter estimation is done by MCMC method
      par_mcmc<-modMCMC(f=cost, p=c(Vmax=0.1, Km=3, m0=1e-3, f=1e-2, Yu=0.5, fr=0.8, fs=0.38, Rinit=40),
                          lower=c(Vmax=1e-5, Km=1e-2, m0=1e-5, f=1e-5, Yu=0, fr=0, fs=0, Rinit=93*0.01),
                          upper=c(Vmax=1, Km=20, m0=10, f=10, Yu=1, fr=1, fs=1, Rinit=93*0.9), niter=10000)

      #lower and upper limits for parameters are extracted
      pl<-summary(par_mcmc)["min",]
      pu<-summary(par_mcmc)["max",]

      #these limits are used to find global optimum by DEoptim
      opt_par<-DEoptim(fn=cost, lower=pl, upper=pu,
                       control = c(itermax = 10000, steptol = 50, reltol = 1e-8,
                                   trace=FALSE, strategy=3, NP=250))

      #global optimum parameters are further used in MCMC to find parameters distribution
      par_prof<-modMCMC(f=cost, p=opt_par$optim$bestmem,
                        lower=pl,
                        upper=pu, niter=5000)

      #goodness of fit
      fit<-rsq_ode(opt_par$optim$bestmem)

      #best parameters
      p<-opt_par$optim$bestmem
      names(p)<-parnames

      #return list with opt_par and par_prof
      estim_out<-list(pars=p, par_prof=par_prof, fit=fit)

      return(estim_out)

    }
    
    res<-estim(odeset=data)


  return(res)

}
```
##Supplementary figure
```{r Monod and MEND model parameters, echo=FALSE, fig.height=24, fig.width=20, message=FALSE, warning=FALSE, paged.print=FALSE, fig.cap="Fig. S1: Monod (a) and MMR (b) model parameters ($V_{MAX}$ - maximum velocity constant, $K_{M}$ - affinity constant, CUE - carbon use efficiency, $k_{MB}$ - microbial biomass decay rate constant, $m_{R}$ - specific maintenance rate constant) estimated separately for three different types of physical barriers presented in incubation bottle (BROTH - black symbols, GLASS - grey symbols and WOOL - empty symbols). Symbols represent best parameters values estimated by the Differential Evolution Algorithm and error bars represent standard deviation of posterior parameters distribution estimated by Constrained Markov Chain Monte Carlo simulation. Parameters estimation was constrained by either observed respiration rates, observed respiration rates and cellular proteins concentration or observed respiration rates and DNA concentration."}

# # Monod model calibrated against the respiration rate (not run)
# # uncertainty of model parameters
# monod_r_sd<-as.data.frame(rbind(apply(monod_r2[[1]]$par_prof$pars, 2, sd),
#                                 apply(monod_r2[[2]]$par_prof$pars, 2, sd),
#                                 apply(monod_r2[[3]]$par_prof$pars, 2, sd)))[,-5]
# colnames(monod_r_sd)<-c("Vmax.sd", "Km.sd", "CUE.sd", "Km.sd")
# #Combine with the estimated parameters
# monod_rs1<-cbind(monod_r_results_par[c(2:4), c(1:4)], monod_r_sd)
# monod_rs1$Legend<-rep("Respiration", times=3)
# 
# # Monod model calibrated against the respiration rate and cellular proteins (not run)
# # uncertainty of model parameters
# monod_all_sd<-as.data.frame(rbind(apply(monod_i2[[1]]$par_prof$pars, 2, sd),
#                                   apply(monod_i2[[2]]$par_prof$pars, 2, sd),
#                                   apply(monod_i2[[3]]$par_prof$pars, 2, sd),
#                                   apply(monod_i2_DNA[[1]]$par_prof$pars, 2, sd),
#                                   apply(monod_i2_DNA[[2]]$par_prof$pars, 2, sd),
#                                   apply(monod_i2_DNA[[3]]$par_prof$pars, 2, sd)))[,-c(5,6)]
# colnames(monod_all_sd)<-c("Vmax.sd", "Km.sd", "CUE.sd", "Km.sd")
# #Combine with the estimated parameters
# monod_alls<-cbind(monod_all_results_par[c(2:4, 14:16), c(1:4)], monod_all_sd)
# monod_alls$Legend<-c(rep("Respiration & Cellular Proteins", times=3),
#                      rep("Respiration & DNA", times=3))
# 
# #Combine monod_alls and monod_rs1
# monod_s<-rbind(monod_rs1, monod_alls)
# #Add labels
# monod_s$Structure<-rep(c("BROTH", "GLASS", "WOOL"), times=3)
# 
# # MEND model calibrated against the respiration rate (not run)
# # uncertainty of model parameters
# mend_r_sd<-as.data.frame(rbind(apply(mend_r2[[1]]$par_prof$pars, 2, sd),
#                                 apply(mend_r2[[2]]$par_prof$pars, 2, sd),
#                                 apply(mend_r2[[3]]$par_prof$pars, 2, sd)))[,-5]
# colnames(mend_r_sd)<-c("Vmax.sd", "Km.sd", "CUE.sd", "Km.sd")
# #Combine with the estimated parameters
# mend_rs1<-cbind(mend_r_results_par[c(2:4), c(1:4)], mend_r_sd)
# mend_rs1$Legend<-rep("Respiration", times=3)
# 
# # MEND model calibrated against the respiration rate and cellular proteins (not run)
# # uncertainty of model parameters
# mend_all_sd<-as.data.frame(rbind(apply(mend_i2[[1]]$par_prof$pars, 2, sd),
#                                   apply(mend_i2[[2]]$par_prof$pars, 2, sd),
#                                   apply(mend_i2[[3]]$par_prof$pars, 2, sd),
#                                   apply(mend_i2_DNA[[1]]$par_prof$pars, 2, sd),
#                                   apply(mend_i2_DNA[[2]]$par_prof$pars, 2, sd),
#                                   apply(mend_i2_DNA[[3]]$par_prof$pars, 2, sd)))[,-c(5,6)]
# colnames(mend_all_sd)<-c("Vmax.sd", "Km.sd", "CUE.sd", "Km.sd")
# #Combine with the estimated parameters
# mend_alls<-cbind(mend_all_results_par[c(2:4, 14:16), c(1:4)], mend_all_sd)
# mend_alls$Legend<-c(rep("Respiration & Cellular Proteins", times=3),
#                      rep("Respiration & DNA", times=3))
# 
# #Combine mend_alls and mend_rs1
# mend_s<-rbind(mend_rs1, mend_alls)
# #Add labels
# mend_s$Structure<-rep(c("BROTH", "GLASS", "WOOL"), times=3)
# 
# write.csv(monod_s, file = c("../monod_FigS1.csv"), row.names = F)
# write.csv(mend_s, file = c("../mend_FigS1.csv"), row.names = F)

monod_s<-read.csv("monod_FigS1.csv")
mend_s<-read.csv("mend_FigS1.csv")

Monod_s<-melt(monod_s[, c(1:4, 9, 10)], id.vars=c("Legend", "Structure"))
Monod_s$sd<-melt(monod_s[, c(5:8, 9, 10)], id.vars=c("Legend", "Structure"))[, "value"]

#add proper parameter labels
mlab<-c('Vmax' = 'V[MAX]',
        'Km' = 'K[M]',
        'CUE' = 'CUE',
        'k' = 'k[MB]')

figS1a<-ggplot(Monod_s, aes(Legend, value))+
  geom_point(shape=21, cex=6, aes(fill=Structure), position = position_dodge(width = 0.6))+
  geom_errorbar(aes(ymin=value-sd, ymax=value+sd, colour=Structure), 
                position = position_dodge(width = 0.6))+
  scale_fill_manual(values = c("black", "grey", "white"))+
  scale_colour_manual(values = c("black", "black", "black"))+theme_min+
  theme(axis.title.x = element_blank(),
        legend.title = element_blank(),
        axis.text.x=element_text(vjust=0.2, size=18, colour="black", angle = 90),
        legend.position = c("top"),
        plot.title=element_text(size=18, face="bold", hjust=-0.01))+
  facet_wrap(~variable, scale="free", nrow=1, 
             labeller = labeller(variable = as_labeller(mlab, label_parsed)))+
  ylab("Parameter value")+ggtitle("a)")

Mend_s<-melt(mend_s[, c(1:4, 9, 10)], id.vars=c("Legend", "Structure"))
Mend_s$sd<-melt(mend_s[, c(5:8, 9, 10)], id.vars=c("Legend", "Structure"))[, "value"]

#add proper parameter labels
mlab2<-c('Vmax' = 'V[MAX]',
        'Km' = 'K[M]',
        'CUE' = 'CUE',
        'mr' = 'm[R]')

figS1b<-ggplot(Mend_s, aes(Legend, value))+
  geom_point(shape=21, cex=6, aes(fill=Structure), position = position_dodge(width = 0.6),
             show.legend = F)+
  geom_errorbar(aes(ymin=value-sd, ymax=value+sd, colour=Structure), 
                position = position_dodge(width = 0.6), show.legend = F)+
  scale_fill_manual(values = c("black", "grey", "white"))+
  scale_colour_manual(values = c("black", "black", "black"))+theme_min+
  theme(axis.title.x = element_blank(),
        legend.title = element_blank(),
        axis.text.x=element_text(vjust=0.2, size=18, colour="black", angle = 90),
        plot.title=element_text(size=18, face="bold", hjust=-0.01))+
  facet_wrap(~variable, scale="free", nrow=1, 
             labeller = labeller(variable = as_labeller(mlab2, label_parsed)))+
  ylab("Parameter value")+ggtitle("b)")

grid.arrange(figS1a, figS1b, nrow=2)

```

